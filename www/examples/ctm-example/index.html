<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">










<html>
  <head>
    <title></title>
    <style type="text/css" media="all">
      @import url("./css/maven-base.css");
      @import url("./css/maven-theme.css");
      @import url("./css/site.css");
    </style>
    <link rel="stylesheet" href="./css/print.css" type="text/css" media="print" />
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
      </head>
  <body class="composite">
    <!-- TODO: move this into JavaScript to patch the skin
      <div class="xright">  </div>
    -->
    <div id="bodyColumn">
      <div id="contentBox">
        <div class="section"><h2>Tenant Managed Scope Example<a name="Tenant_Managed_Scope_Example"></a></h2><p>This directory contains an example that illustrates how a scope can be made that is tenant aware. First, lets define a tenant.</p><p>A tenant is a an entity who has certain attributes that are backed by an XML configuration file. The XML configuration file will contain all the information about that tenant. For example, this XML contains all the data about a Tenant named Alice</p><div class="source"><pre>&lt;environments&gt;
    &lt;environment name=&quot;Alice&quot; minSize=&quot;1&quot; maxSize=&quot;2&quot; /&gt;
&lt;/environments&gt;</pre></div><p>This XML contains all the data about a tenant named Bob</p><div class="source"><pre>&lt;environments&gt;
    &lt;environment name=&quot;Bob&quot; minSize=&quot;10&quot; maxSize=&quot;20&quot; /&gt;
&lt;/environments&gt;</pre></div><p>The CTM team would like to have an interface called Environment that encapsulates all the information about a tenant:</p><div class="source"><pre>public interface Environment {
    String getName();
    int getMinSize();
    int getMaxSize();
}</pre></div><p>There is code in the system that would like to inject the Environment class. However, the code that will inject this interface is in the Singleton scope, which means it never changes. And yet, depending on the state of the system the underlying tenant may change from Alice to Bob, or to any other tenant. For example, the class could look like this:</p><div class="source"><pre>@Singleton
public class ServiceProvisioningEngine {

   @Inject
   private Environment tenant;

   private void provisionServices() {
       //envs here could be  either env1   or  env2 depending on
       //   whether this code is being executed on behalf of either tenant1 OR tenant2
   }

}</pre></div><p>We would like to demonstrate how a custom scope, called the TenantScope, can be used to solve this problem. Firstly, in order to solve the problem of the Singleton service getting injected with the Environment only at construction time, we must have HK2 inject a proxy for the Environment service rather than the particular environment itself. The proxy can figure out, depending on the state of the system, which tenant is active, and then use the proper Environment object for the real call. In order to ensure that this proxy is created, the TenantScope must be Proxiable. You mark a scope as being Proxiable by adding the @Proxiable annotation to the definition of the scope annotation itself, like this:</p><div class="source"><pre>@Scope
@Proxiable
@Retention(RUNTIME)
@Target( { TYPE, METHOD })
public @interface TenantScoped {
}</pre></div><p>This annotation is now marked as a scope indicator (via the @Scope annotation) and as proxiable (via the @Proxiable annotation). All objects that are injected from this scope will be given a proxy that uses the underlying machinery to determine the state of the system and to use the proper backing objects for the real calls.</p><p>Now, however, we need some way to tell the system what tenant is currently active. For this example, we have created a class called the TenantManager. The TenantManager is in the Singleton scope which means it will only be created once (when the first person demands one). The job of the TenantManager is to be able to set the currently active tenant. It does so with this call:</p><div class="source"><pre>@Service
public class TenantManager {
    private String currentTenant;
    
    public void setCurrentTenant(String currentTenant) {
        this.currentTenant = currentTenant;
    }
    
    public String getCurrentTenant() {
        return currentTenant;
    }</pre></div><p>OK, great, now we know how to change the current tenant that is running on the system. But how do we make the system understand this? Well, since we decided that we were going to have a proxiable scope, we also need a corresponding implementation of the Context interface. You do this by implementing Context, and making sure that the parameterized type of the Context is the class of the scope annotation. In this case, we would implement the context for the TenantScope scope like this:</p><div class="source"><pre>@Singleton
public class TenantScopedContext implements Context&lt;TenantScoped&gt; {
    @Inject
    private TenantManager manager;
    ...</pre></div><p>Note that the implementation of Context is itself a service, in the Singleton scope (there is nothing that says a Context must be in the Singleton scope, but most probably would be). The only rule is that a Context implementation cannot be in the same scope as the scope it is backing. Also notice that since Context is a regular service that it can be injected with other services, such as the TenantManager. Luckily, that is just what we need, since the TenantManager knows what the current scope is! First, lets see what the implementation of the isActive method of the TenantScopedContext would look like:</p><div class="source"><pre>    public boolean isActive() {
        return manager.getCurrentTenant() != null;
    }</pre></div><p>That was pretty easy. But now lets think about what the TenantScopeContext has to do. It must keep the set of objects created per tenant. For example, we do not want to create the Environment implementation for the Alice tenant more than once. And so the TenantScopeContext keeps a mapping for each tenant. Here is the map, and the code that gets the proper mapping based on the current tenant:</p><div class="source"><pre>    private final HashMap&lt;String, HashMap&lt;ActiveDescriptor&lt;?&gt;, Object&gt;&gt; contexts = new HashMap&lt;String, HashMap&lt;ActiveDescriptor&lt;?&gt;, Object&gt;&gt;();
    
    private HashMap&lt;ActiveDescriptor&lt;?&gt;, Object&gt; getCurrentContext() {
        if (manager.getCurrentTenant() == null) throw new IllegalStateException(&quot;There is no current tenant&quot;);
        
        HashMap&lt;ActiveDescriptor&lt;?&gt;, Object&gt; retVal = contexts.get(manager.getCurrentTenant());
        if (retVal == null) {
            retVal = new HashMap&lt;ActiveDescriptor&lt;?&gt;, Object&gt;();
            
            contexts.put(manager.getCurrentTenant(), retVal);
        }
        
        return retVal;
    }</pre></div><p>Based on this code, it is now easy to write the find method of the TenantScopedContext:</p><div class="source"><pre>    public &lt;T&gt; T find(ActiveDescriptor&lt;T&gt; descriptor) {
        HashMap&lt;ActiveDescriptor&lt;?&gt;, Object&gt; mappings = getCurrentContext();
        
        return (T) mappings.get(descriptor);
    }</pre></div><p>The method that does findOrCreate is also fairly simple to write now. If it cannot find the service in the mapping for this tenant, then it must create one using the create method of the ActiveDescriptor, passing in the root. The passing in of the root allows for objects of scope PerLookup to be destroyed properly when this object gets destroyed.</p><div class="source"><pre>    public &lt;T&gt; T findOrCreate(ActiveDescriptor&lt;T&gt; activeDescriptor,
            ServiceHandle&lt;?&gt; root) {
        HashMap&lt;ActiveDescriptor&lt;?&gt;, Object&gt; mappings = getCurrentContext();
        
        Object retVal = mappings.get(activeDescriptor);
        if (retVal == null) {
            retVal = activeDescriptor.create(root);
            
            mappings.put(activeDescriptor, retVal);
        }
        
        return (T) retVal;
    }</pre></div><p>That is it for writing the Context implementation for the TenantScope! At this point, objects will be created in the tenant scope only when no object has already been created for that tenant. And when a tenant is switched, a new mapping is generated and we start the process all over again.</p><p>That is all well and good, but the question of how these objects are truly created for the TenantScope is still unclear. For example, we need for the Alice Environment implementation to be produced when the Alice tenant is active, and we need the Bob Environment to be produced when the Bob tenant is active.</p><p>In order to achieve this goal, we create a factory of Environments. A factory can be used to create objects when some criteria that cannot be easily expressed as an injection point needs to be taken into account. Factories can produce things into any scope and with any qualifiers. The Factory interface has a method on it called produce(), which can be annotated with the scope and qualifiers that are to be associated with the produced objects.</p><p>We then implement an EnvironmentFactory, giving the type we are producing as the actual type in the parameterized type, like this:</p><div class="source"><pre>@Singleton
public class EnvironmentFactory implements Factory&lt;Environment&gt; {
    @Inject
    private TenantManager manager;
    
    ...
}</pre></div><p>It is interesting to notice that the factory itself is a service in the Singleton scope, and hence can be injected with the TenantManager. However, that does not mean that the EnvironmentFactory is producing objects into the Singleton scope, only that the factory itself is in the Singleton scope. We tell the system that this factory is producing items for the TenantScope by annotating the produce method, like this:</p><div class="source"><pre>    @TenantScoped
    public Environment provide() {...}</pre></div><p>In this example, we are going to use other ServiceLocator registry's in order to create the specific Environment objects that we need. We will have a new ServiceLocator registry for each tenant, and that new ServiceLocator will be responsible for instantiating and providing the Environment implementations that we require.</p><p>ServiceLocators will be used as delegate for Habitat to create config instance of Environments based on a particular backing XML file, using the configuration subsystem of hk2.</p><p>Thus the job of the EnvironmentFactory is to keep a map from tenants to their backing ServiceLocator registries. Here is the mapping and the code that associates a particular ServiceLocator with the current tenant:</p><div class="source"><pre>    private final HashMap&lt;String, ServiceLocator&gt; backingLocators = new HashMap&lt;String, ServiceLocator&gt;();
    private final TenantLocatorGenerator generator = new TenantLocatorGenerator();
    
    private ServiceLocator getCurrentLocator() {
        if (manager.getCurrentTenant() == null) throw new IllegalStateException(&quot;There is no current tenant&quot;);
        
        ServiceLocator locator = backingLocators.get(manager.getCurrentTenant());
        if (locator == null) {
            locator = createNewLocator();
            backingLocators.put(manager.getCurrentTenant(), locator);
        }
        
        return locator;
    }
    
    private ServiceLocator createNewLocator() {
        return generator.generateLocatorPerTenant(manager.getCurrentTenant());
    }</pre></div><p>The job of the TenantLocatorGenerator is to create a new ServiceLocator based on the current tenant and populate it with values from a backing XML file.</p><div class="source"><pre>        ServiceLocator serviceLocator = factory.create(tenantName, parent);

        // Will add itself to serviceLocator by tenantName
        Habitat h = new Habitat(null, tenantName);
        
        // Populate this serviceLocator with config data.
        for (Populator p : serviceLocator.&lt;Populator&gt;getAllServices(Populator.class)) {
            p.run(new ConfigParser(h));
        }</pre></div><p>Then it is necessary to implement Populator service, as follows below. Note, Habitat is backed by ServiceLocator for tenant.</p><div class="source"><pre>                @Service
                public class EnvironmentXml implements Populator {
                    @Inject
                    TenantManager tenantManager;
                
                    @Inject
                    protected Habitat habitat;
                
                    @Override
                    public void run(ConfigParser parser) throws ConfigPopulatorException {
                        String tenantName = tenantManager.getCurrentTenant();
                        URL source = URL&lt;tenantName.xml&gt;
                        parser.parse(source, new DomDocument(habitat));
                    }
                
                }</pre></div><p>The code of the produce method in the EnvironmentFactory is now straightforward:</p><div class="source"><pre>    @TenantScoped
    public Environment provide() {
        ServiceLocator locator = getCurrentLocator();
        
        return locator.getService(Environment.class);
    }</pre></div><p>Voila! We have a fairly simple example of how to create a TenantContext that meets the original requirements. We have created a TenantScope/TenantContext pair, and made sure it only creates objects when no object already exists for a certain tenant. We have also seen how to write a factory which knows how to produce Environment objects based on the currently active tenant. </p><p>Now, lets take a look at the test, and how the test validates the original requirement, which was that the ServiceProviderEngine should be using the proper tenant based on the current state of the system, without having to be re-injected. Here is the pseudo-code for the test:</p><div class="source"><pre>    TenantManager tenantManager = locator.getService(TenantManager.class);
    ServiceProviderEngine engine = locator.getService(ServiceProviderEngine.class);
        
    tenantManager.setCurrentTenant(TenantLocatorGenerator.ALICE);
        
    // Validate that the engine is using the ALICE tenant
        
    tenantManager.setCurrentTenant(TenantLocatorGenerator.BOB);
        
    // Validate that the engine is using the BOB tenant</pre></div><p>The point of the test is to ensure that the Environment object passed into the ServiceProviderEngine is in fact getting switched when we switch the tenant from Alice to Bob.</p></div>
      </div>
    </div>
    <div class="clear">
      <hr/>
    </div>
    <div id="footer">
      <div class="xright">&#169;  
          2012
    
          Oracle Corporation
          
  

  
  
  &nbsp;| Last Published: 07/14/2012
  &nbsp;| Version: 2.1.10-SNAPSHOT
</div>
      <div class="clear">
        <hr/>
      </div>
    </div>
  </body>
</html>
