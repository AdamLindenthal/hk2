<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">










<html>
  <head>
    <title></title>
    <style type="text/css" media="all">
      @import url("./css/maven-base.css");
      @import url("./css/maven-theme.css");
      @import url("./css/site.css");
    </style>
    <link rel="stylesheet" href="./css/print.css" type="text/css" media="print" />
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
      </head>
  <body class="composite">
    <!-- TODO: move this into JavaScript to patch the skin
      <div class="xright">  </div>
    -->
    <div id="bodyColumn">
      <div id="contentBox">
        <p>DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.</p><p>Copyright (c) 2010-2011 Oracle and/or its affiliates. All rights reserved.</p><p>The contents of this file are subject to the terms of either the GNU General Public License Version 2 only (&quot;GPL&quot;) or the Common Development and Distribution License(&quot;CDDL&quot;) (collectively, the &quot;License&quot;). You may not use this file except in compliance with the License. You can obtain a copy of the License at https://glassfish.dev.java.net/public/CDDL+GPL_1_1.html or packager/legal/LICENSE.txt. See the License for the specific language governing permissions and limitations under the License.</p><p>When distributing the software, include this License Header Notice in each file and include the License file at packager/legal/LICENSE.txt.</p><p>GPL Classpath Exception: Oracle designates this particular file as subject to the &quot;Classpath&quot; exception as provided by Oracle in the GPL Version 2 section of the License file that accompanied this code.</p><p>Modifications: If applicable, add the following below the License Header, with the fields enclosed by brackets [] replaced by your own identifying information: &quot;Portions Copyright [year] [name of copyright owner]&quot;</p><p>Contributor(s): If you wish your version of this file to be governed by only the CDDL or only the GPL Version 2, indicate your decision by adding &quot;[Contributor] elects to include this software in this distribution under the [CDDL or GPL Version 2] license.&quot; If you don't indicate a single choice of license, a recipient has the option to distribute your version of this file under either the CDDL, the GPL Version 2 or to extend the choice of license to its licensees as provided above. However, if you add GPL Version 2 code and therefore, elected the GPL Version 2 license, then the option applies only if the new code is made subject to such option by the copyright holder.</p><p>------ Run Level Services ------ Jeff Trent ------ ---</p><div class="section"><h2>Introduction<a name="Introduction"></a></h2><p>The RunLevelService was designed to offer life cycle controller mechanisms to a system. Life cycle involves the starting or stopping of a system in phases, known as run levels.</p><p>This is a departure from the traditional, ternary style of system life cycle which was represented by the state machine (NotStarted_or_Shutdown <i>--</i> Starting_or_Stopping <i>--</i> Running). The issue with the traditional approach is that it doesn't offer the proper granularity to target more nuanced features. For example, consider an application server that wants to startup to a level where it can managed by a systems administrator but before it is made available for general public use. By adding an &quot;admin run level&quot; the state machine for the application server now becomes (NotStarted_or_Shutdown <i>--</i> Starting_or_Stopping <i>--</i> <b>Admin</b> <i>--</i> Running).</p><p>The RunLevelService was also designed to support sub-systems within the global system, where the same life cycle controllers can be used, but having a different set of run levels that are meaningful to that sub-system.</p></div><div class="section"><h2>Overview<a name="Overview"></a></h2><p>The HK2 component system uses <a href="./hk2-api/apidocs/org/jvnet/hk2/annotations/RunLevel.html">RunLevel</a> to form higher levels of component life cycle. HK2 normally employs a &#x201c;lazy instantiation&#x201d; model for component creation. However, there are situations where the developer may want the instantiation to occur either immediately upon HK2 initialization or otherwise on some more regimented schedule. This can be accomplished using the RunLevel annotation.</p><div class="section"><h3>RunLevel's<a name="RunLevels"></a></h3><p>The <a href="./hk2-api/apidocs/org/jvnet/hk2/annotations/RunLevel.html">RunLevel</a> is a declarative form of annotation that you place on your Service class as shown in this example.</p><div class="source"><pre>@RunLevel(1)
@Service
public MyService implements MyContract {
...
}</pre></div><p>In this example, MyService was declared to be in run level &quot;1&quot; in the default, or global, run level scoping. This is called the run level value (in OSGi this is similar to the start level). The run level value must be an integer value. Run Level Scoping will be explained later.</p></div><div class="section"><h3>RunLevelService<a name="RunLevelService"></a></h3><p>The <a href="./auto-depends/apidocs/org/jvnet/hk2/component/RunLevelService.html">RunLevelService</a> is the controller responsible for (automatically) instantiating services annotated with the RunLevel annotation using the proceedTo() method on the RunLevelService interface.</p><div class="source"><pre>...
@Inject
RunLevelService rls;

public void start() {
  rls.proceedTo(1);
}
...</pre></div><p>It is also possible to interrogate the current and planned run levels (if the RunLevelService is currently operating) using the getState() method of the interface.</p></div><div class="section"><h3>Runtime Start Order<a name="Runtime_Start_Order"></a></h3><p>When two services are found to be in the same RunLevel they will be instatiated during the RunLevelService's proceedTo() operation provided that the run level value on the service is less than or equal to the argument passed to proceedTo(). The RunLevel service operates one run level value at a time.</p><div class="source"><pre>@RunLevel(1)
@Service
public MyService1 implements MyContract {
}

@RunLevel(1)
@Service
public MyService2 implements MyContract {
}

@RunLevel(2)
@Service
public MyService3 implements MyContract {
}

@RunLevel(2)
@Service
public MyService4 implements MyContract {
  @Inject
  MyService3 myService3;
}</pre></div><p>In this example, assuming we start from run level vlaue 0, a call to rls.proceedTo(2) will first instantiate (MyService1 | MyService2). While both services will eventually be instantiated, it is non-deterministic which of the two will actually come first (more on this later).</p><p>After all services annotated with the value of 1 in the default/global run level scope is located and instantiated from the HK2 service registry the system will proceed to run level value 2. This case is different in that the start order is deterministic - at least with respect to MyService3 and MyService4. MyService3 must be started before MyService4 because MyService4 depends upon (i.e., injects) MyService3.</p></div><div class="section"><h3>Runtime Stop Order<a name="Runtime_Stop_Order"></a></h3><p>The <a href="./auto-depends/apidocs/org/jvnet/hk2/component/RunLevelService.html">RunLevelService</a> can also be used to shutdown / release services that were previously instantiated. Continuing from the previous example, a call to proceedTo(0) will release MyService1 - MyService4. Note that shutdown will occur in the reverse order from the instantiation order. So the shutdown order will therefore be MyService4, MyService3, (MyService1 | MyService2).</p></div><div class="section"><h3>The &quot;Kernel&quot; RunLevel<a name="The_Kernel_RunLevel"></a></h3><p>The kernel run level has the value -1. It is considered special in that Services annotated with it will be instantiated immediately upon HK2 startup.</p></div><div class="section"><h3>Meta Annotations<a name="Meta_Annotations"></a></h3><p>As a convenience, you can create a meta annotation (i.e., stereotype) to use a more meaningful name/type to describe your RunLevel. HK2 comes with one such meta-annotation called @Immediate having run level value -1 as described above.</p><div class="source"><pre>@Retention(RUNTIME)
@Target(TYPE)
@Inherited
@RunLevel(RunLevel.KERNEL_RUNLEVEL)
public @interface Immediate {}</pre></div></div><div class="section"><h3>RunLevel Scope<a name="RunLevel_Scope"></a></h3><p>The RunLevel Scope, not to be confused with component <a href="./hk2-api/apidocs/org/glassfish/hk2/Scope.html">Scope</a>, permits namespace groupings of services to occur. When not declared on the RunLevel annotation, the default, or global, run level scope is implied. A class type is used to represent the run level scope and will default to <a href="./hk2-api/apidocs/org/glassfish/hk2/RunLevelDefaultScope.html">RunLevelDefaultScope</a> unless otherwise specified.</p><p>RunLevel scoping is useful for modeling life cycle for sub-systems which span more than a single service (e.g., &quot;the ejb container&quot;, &quot;the logging sub system&quot;, etc.).</p><p>See <a href="#Extensions">Extensions</a> for more information</p></div></div><div class="section"><h2>The Default RunLevelService<a name="The_Default_RunLevelService"></a></h2><p>HK2 comes configured with a default RunLevelService responsible for the services that are using the default, or global, RunLevel scope. The default RunLevel Service delegates part of its work to other services it attempts to find from the HK2 service registry. These services include the <a href="./auto-depends/apidocs/org/jvnet/hk2/component/InhabitantSorter.html">InhabitantSorter</a> and the <a href="./auto-depends/apidocs/org/jvnet/hk2/component/InhabitantActivator.html">InhabitantActivator</a>.</p><p>In addition to delegating work to the sorter and activator, the default RunLevelService sends certain events to it's RunLevelListener(s).</p><div class="section"><h3>The Inhabitant Sorter and Priority<a name="The_Inhabitant_Sorter_and_Priority"></a></h3><p>Earlier it was suggested that the start order of services in the same run level is non-deterministics. This is a partially true statement because the services were unrelated to one another. The &quot;real&quot; answer is as follows. The start order can be established within a given run level when either there is (a) an InhabitantActivator applied, or (b) the default inhabitant activator is used in conjunction with <a href="./hk2-api/apidocs/org/jvnet/hk2/annotations/Priority.html">Priority</a> annotation being applied to the service. Otherwise the start order can be assumed to be non-deterministic.</p><p>Callers can declare a service implementing the InhabitantActivator or apply the Priority annotations to affect the behavior of the default RunLevelService.</p></div><div class="section"><h3>The Inhabitant Activator<a name="The_Inhabitant_Activator"></a></h3><p>The InhabitantActivator service is another service that can be optionally declared in order to have the default RunlevelService delegate the actually instantiation/ activation during startup and also the release/deactivation during shutdown.</p></div><div class="section"><h3>The RunLevelListener<a name="The_RunLevelListener"></a></h3><p>The set of <a href="./auto-depends/apidocs/org/jvnet/hk2/component/RunLevelListener.html">RunLevelListener</a>s associated with the default RunLevelService will be notified of important events during it's operations. It is important to note that the default RunLevelService captures most Throwable types and sends them to the listeners - in general Exceptions are not emitted out to the caller of the default RunLevelService. The listeners are also notified of progress and cancellation events.</p><div class="section"><h4>Interruption<a name="Interruption"></a></h4><p>In the event the listener encounters a critical error and it is desirable for the operations of the default RunLevelService to be aborted, then an interrupt() could be called on the RunLevelService instance. The implementation is thread safe so that interrupt() can be called from the listener or by some other monitoring thread.</p></div><div class="section"><h4>AsyncPostConstruct<a name="AsyncPostConstruct"></a></h4><p>In some situations, a component / service acts in such a way that it spawns threads to complete other internal initialization operations. In such situations it is recommended that the service implements <a href="./hk2-api/apidocs/org/glassfish/hk2/AsyncPostConstruct.html">AsyncPostConstruct</a> instead of the standard PostConstruct contract. The default RunLevelService will wait for all asynchronous operations to complete at a given run level before attempting to continue the startup process proceeding to subsequent run levels.</p></div></div></div><div class="section"><h2>Extensions<a name="Extensions"></a></h2><p>As shown previously, run level scoping can be used useful for modeling life cycle of sub-systems. Here is an example of how run level scope can be declared on a service.</p><div class="source"><pre>@RunLevel(2, runLevelScope=MySubsystemScope.class)
@Service
public MySubsystemService implements MyContract {
}</pre></div><p>Here, MySubsystemService is now mapped to the MySubsystemScope run level scope. Note that it's perfectly fine to also declare meta-annotations for scoped run levels as well.</p><p>It is important to note that if you are using run level scoping extensions, you will also be responsible for implementing a <a href="./auto-depends/apidocs/org/jvnet/hk2/component/RunLevelService.html">RunLevelService</a> associated with your scope. Fortunately, HK2 provides an easy way to do this by extending the <a href="./auto-depends/apidocs/org/jvnet/hk2/component/AbstractRunLevelService.html">AbstractRunLevelService</a>.</p><div class="source"><pre>@Service(metadata=RunLevel.META_SCOPE_TAG + &quot;=...package-to...MySubsystemScope&quot;)
public class MySubsystemRunLevelService extends AbstractRunLevelService&lt;MySubsystemScope&gt; {
    public MySubsystemRunLevelService() {
        super(MySubsystemScope.class);
    }
}</pre></div><p>The RunLevel.META_SCOPE_TAG set in the metadata of the system is the important point to remember. The same approach for setting the metadata having RunLevel.META_SCOPE_TAG should also be used when creating custom activators, sorters, and listeners. Any instance of these types that are not annotated in this way will be assumed to belong to the default RunLevelService. The AbstractRunLevelService provides setters to override some of this default functionality - see the javadoc for details.</p></div><div class="section"><h2>Constraint Rules<a name="Constraint_Rules"></a></h2><p>RunLevel annotated services are different from normal services because they are governed by different life cycle rules. Imagine a situation where a non-RunLevel annotated service declares an injection point of a RunLevel annotated service.</p><div class="source"><pre>@Service
public StandardService {
  @Inject
  MyService4 myService4;
}

@RunLevel(2)
@Service
public MyService4 implements MyContract {
}</pre></div><p>If someone attempt to obtain (or be injected with) a StandardService, it is ambiguous whether or not the operation can be successful since it depends on the state of the default run level service. If the current run level is 0 then the StandardService cannot be instantiated because it needs a MyService4 instance that is not permitted to be created until run level value 2 is reached. Furthermore, assume that the run level is current at 3, and HK2 permitted the acquisition of StandardService injected with an instance of MyService4. Now, if partial shutdown occurs (i.e., proceedTo(1)) then the StandardService#myService4 instance becomes an orphan from the Habitat and may cause an error.</p><p>These issues are avoided by three semantical constraints placed on the use of RunLevel annotated services. These rules include:</p><ul><li>A standard, non-RunLevel annotated service can not be injected with a RunLevel annotated service.</li><li>A RunLevel annotated service with run level value N can not be injected with a RunLevel annotated service with value M when M &gt; N.</li><li>A RunLevel annotated service in run level scope X cannot be injected with a RunLevel annotated service in run level scope Y when X != Y.</li></ul><p><b>All rules are enforced at runtime.</b></p><p>There are two exceptions that are provided to bypass these constraint rules:</p><ul><li>Holder-style injection bypasses the normal constraint rules.<p>The Holder will act as a proxy to the service and be set to null when the service has not been activated, and a non-null value when it has been instantiated.</p><div class="source"><pre>@Service
public StandardService {
  @Inject
  Holder&lt;MyService4&gt; myService4Holder;
}

@RunLevel(2)
@Service
public MyService4 implements MyContract {
}</pre></div><p>It is important to note, however, that the service instance obtained from the Holder should never be cached or otherwise held unto for extended periods of time (i.e., not carried in a class field) since the run level annotated service can eventually be nulled when the run level service responsible for that service is shutting down. Also be careful to perform null checks at all times.</p></li><li>RunLevel(strict=false)<p>Declaring the run level with strict=false simply provides a means to create demand for the service when reaching the given run level. It will NOT, however, be managed / released as part of shutdown processing.</p><p>See the javadoc for additional details.</p></li></ul></div>
      </div>
    </div>
    <div class="clear">
      <hr/>
    </div>
    <div id="footer">
      <div class="xright">&#169;  
          2011
    
          Oracle Corporation
          
  

  
  
  &nbsp;| Last Published: 09/07/2011
  &nbsp;| Version: 1.6.18-SNAPSHOT
</div>
      <div class="clear">
        <hr/>
      </div>
    </div>
  </body>
</html>
