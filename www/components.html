<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">










<html>
  <head>
    <title>hk2 - </title>
    <style type="text/css" media="all">
      @import url("./css/maven-base.css");
      @import url("./css/maven-theme.css");
      @import url("./css/site.css");
    </style>
    <link rel="stylesheet" href="./css/print.css" type="text/css" media="print" />
        <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" />
      </head>
  <body class="composite">
    <!-- TODO: move this into JavaScript to patch the skin
      <div class="xright">      <a href="http://glassfish.dev.java.net/">Glassfish</a>
      </div>
    -->
    <div id="leftColumn">
      <div id="navcolumn">
             <dl class=navgroup>
        <dt>Module Subsystem</dt>
        <dd><ul>
              
    <li class="none">
              <a href="index.html">Introduction</a>
        </li>
          </ul></dd>
    </dl>
      <dl class=navgroup>
        <dt>Modules APIs</dt>
        <dd><ul>
              
    <li class="none">
              <a href="apidocs/index.html">APIs</a>
        </li>
          </ul></dd>
    </dl>
      <dl class=navgroup>
        <dt>Components APIs</dt>
        <dd><ul>
              
    <li class="none">
              <a href="auto-depends/apidocs/index.html">APIs</a>
        </li>
          </ul></dd>
    </dl>
      <dl class=navgroup>
        <dt>Project Documentation</dt>
        <dd><ul>
              
                
              
      
            
      
            
      
            
      
            
      
            
      
            
      
            
      
              
        <li class="collapsed">
              <a href="project-info.html">Project Information</a>
              </li>
          </ul></dd>
    </dl>
        </div>
      <script>
        // replace the java.net project tools with the navigation bar from Maven.
        // also get rid of "Get Involved" thingie too, while we are at it
        var pt = document.getElementById("projecttools");
        var nv = document.getElementById("navcolumn");
        
        while(pt.previousSibling!=null)
          pt.parentNode.removeChild(pt.previousSibling);
        
        pt.parentNode.insertBefore(nv,pt);
        pt.parentNode.removeChild(pt);
      </script>
      <script>
        // kill "description" h3 bar
        var ld = document.getElementById("longdescription");
        if(ld!=null) {
          for( n=ld.firstChild; n!=null; n=n.nextSibling ) {
            if(n.nodeType==1 && n.innerHTML=="Description" ) {
              n.parentNode.removeChild(n);
              break;
            }
          }
        }
      </script>
    </div>
    <div id="bodyColumn">
      <div id="contentBox">
        <div class="section"><h2>Introduction</h2><p>With the GF v3 module system, the module system is already responsible for instanciating many classes that constitute the application functionality.</p><p>HK2 components runtime will complement the module system so that it creates objects, but it configures such objects by:</p><ul><li>injecting other objects that are needed by a newly instanciated object.</li><li>injecting configuration information needed for that object.</li><li>making newly created objects available, so that it can be then injected to other objects that need it.</li></ul></div><div class="section"><h2>Services</h2><p>HK2 relies on the notion of Service to identify the building blocks or the extension points of an application. Services are just POJO :</p><ul><li>implementating an interface</li><li>declared in jar with the META-INF/services file<p>To clearly separatethe contract interface and its implementation, the HK2 runtime needs to understand what interfaces are contract and what implemenations of such interfaces are services, so this call for an annotation describing interfaces as a service contract.</p><div class="source"><pre>@Retention(RUNTIME)
@Target(TYPE)
public @interface Contract {   
}</pre></div><p>Implementations of such contract should also be annotated with an annotation so the HK2 runtime can identify them as contracts implementations.</p><div class="source"><pre>@Retention(RUNTIME)
@Target(TYPE)
public @interface Service {
...
}</pre></div><p>see <a href="auto-depends/apidocs/org/jvnet/hk2/annotations/Service.html">Service</a> for complete reference</p></li></ul><div class="section"><h3>Build System</h3><p>When using maven 2 to build HK2 components, users should invoke the auto-depends plugin for maven so the META-INF/services files are generated automatically during build time.</p><p>Example of the maven plugin configuration :</p><div class="source"><pre>            &lt;plugin&gt;
                &lt;groupId&gt;com.sun.enterprise&lt;/groupId&gt;
                &lt;artifactId&gt;hk2-maven-plugin&lt;/artifactId&gt;
                &lt;configuration&gt;
                    &lt;includes&gt;
                        &lt;include&gt;com/sun/enterprise/v3/**&lt;/include&gt;
                    &lt;/includes&gt;
                &lt;/configuration&gt;
            &lt;/plugin&gt;</pre></div><p>Example on how to use <a href="auto-depends/apidocs/org/jvnet/hk2/annotations/Contract.html">@Contract</a> and <a href="auto-depends/apidocs/org/jvnet/hk2/annotations/Service.html">@Service</a> and resulting META-INF/services files.</p><div class="source"><pre>package com.sun.v3.annotations;
@Contract
public interface Startup {...}


package com.wombat;
@Contract
public interface RandomContract {...}


package com.sun.v3;
@Service
public class MyService implements Startup, RandomContract, PropertyChangeListener {
...
}</pre></div><p>will generate the following META-INF/services files :</p><div class="source"><pre>com.sun.v3.annotations.Startup
com.wombat.RandomContract
with the com.sun.v3.MyService content    </pre></div></div><div class="section"><h3>Runtime</h3><p>Once Services are defined, HK2 runtime can be used to instantiate or retrieve instances of services. Each service instance can be scoped to be Singleton, per thread, per application or custom. This allow for greater flexibility.</p><div class="section"><h4>Scopes</h4><p>Scopes are services themselves, so they can be custom defined and added to the HK2 runtime before being used by other services. Each scope is responsible for storing the services instances which are tied to itself, therefore HK2 runtime does not rely on predefined scopes (although it comes with a few predefined ones).</p><div class="source"><pre>@Contract
public abstract class Scope {
    public abstract ScopeInstance current();
}</pre></div><p>Example of scoping for service to the predefined <a href="org.jvnet.hk2.component.Singleton.html">Singleton</a> Scope</p><div class="source"><pre>@Service
public Singleton implements Scope {
...
}

@Scope(Singleton.class)
@Service
public class SingletonService implements RandomContract {
...
}</pre></div><p>For the curious reader, you can experiment defining a new Scope implementation and have that scope used on your @Service implementations. You will see that the HK2 runtime use the Scope instance to store/retrieve services instances tied to that scope.</p></div><div class="section"><h4>Instantiation</h4><p>Instantiation of components</p><p>In the IoC world, components are not instantiated using a new () method call. Components are retrieved using the ComponentManager instance. The simplest way is to do that is through a getComponent(Class<i>T</i> contract) call although there are more APIs available at <a href="auto-depends/apidocs/org/jvnet/hk2/compinent/ComponentManager.html">ComponentManager</a></p><div class="source"><pre>    /**
     * Obtains a reference to the component inside the manager.
     *
     * &lt;p&gt;
     * This is the &quot;new Foo()&quot; equivalent in the IoC world.
     *
     * &lt;p&gt;
     * Depending on the {@link Scope} of the component, a new instance
     * might be created, or an existing instance might be returned.
     *
     * @return
     *      non-null.
     * @throws ComponentException
     *      If failed to obtain a requested instance.
     *      In practice, failure only happens when we try to create a
     *      new instance of the component.
     */
    public &lt;T&gt; T getComponent(Class&lt;T&gt; clazz) throws ComponentException</pre></div></div><div class="section"><h4>Lifecycle</h4><p>Components can attach behaviours to their construction and destruction events by implementing the <a href="auto-depends/apidocs/org/jvnet/hk2/component/PostContruct.html">PostConstruct</a> and/or the <a href="auto-depends/apidocs/org/jvnet/hk2/component/PreDestroy.html">PreDestroy</a> interfaces. Interfaces have been used rather than annotations for performance as it is faster to cast component instance to any of these interfaces to check if the component has implemented one of them rather than using reflection on all methods to find if they are annotated.</p></div></div></div><div class="section"><h2>Inversion of Control</h2><div class="section"><h3>Injection</h3><p>Services usually rely of other services to perform their tasks and the model described above can easily be extended to have the HK2 runtime identify the @Contract implementations required by a service. This call for a new annotation <a href="auto-depends/apidocs/org/jvnet/hk2/annotations/Inject.html">Inject</a> which can be placed on fields or setter methods of any Service instantiated by the HK2 runtime and have that Service retrieved and injected during the service's instantiation by the component manager.</p><div class="source"><pre>Field :
@Inject
ConfigService config;

Setter method :
@Inject
public void set(ConfigService svc) {..}</pre></div><p>Injection can further qualify the intended injected service implementation by using a name and scope from which the service should be available.</p><div class="source"><pre>@Inject(Scope=Singleton.class, name=&quot;deploy&quot;)
AdminCommand deployCommand;</pre></div></div><div class="section"><h3>Extraction</h3><p>Although all Services are automatically placed into the Scope for later retrieval, it is conceivable that a component want to extract more than itself. One pratical way of doing so is to use a Factory service, however, for simplicity, the HK2 runtime will also extract all fields or getter methods annotated with <a href="auto-depends/apidocs/org/jvnet/hk2/annotations/Extract.html">Extract</a></p><div class="source"><pre>Field :
@Extract
ConfigService config;

Getter method :
@Extract
public ConfigService getConfigService() {..}</pre></div><p>Extraction can also use the name and scope annotation fields to further qualify the extracted Contract implementation.</p></div><div class="section"><h3>Instantiation cascading</h3><p>Injection of instances which have not been already instantiated triggers more instantiation. In a sense, you can see this as a components instantiation cascading where some code requests for a high level Service will in turn throuh @Inject annotation requires more injection/instantiation of lower level Services. This important feature is a great tool to keep the implementation as private as possible while relying on interfaces and separation of contract/providers.</p><p>Below is the example of how the instantiation of DeploymentService as a Startup contract implementation will trigger the instantiation of the ConfigService.</p><div class="source"><pre>@Contract
public interface Startup {...}

Iterable&lt;Startup&gt; startups;
startups = componentMgr.getComponents(Startup.class);

@Service
public class DeploymentService implements Startup {

    @Inject
    ConfigService config;
}

@Service
public Class ConfigService implements ... {...}
</pre></div></div></div>
      </div>
    </div>
    <div class="clear">
      <hr/>
    </div>
    <div id="footer">
      <div class="xright">&#169;  
          2007
    
          
  

  
  
  &nbsp;| Last Published: 05/02/2007
  &nbsp;| Version: 0.1-SNAPSHOT
</div>
      <div class="clear">
        <hr/>
      </div>
    </div>
  </body>
</html>
