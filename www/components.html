<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">










<html>
  <head>
    <title></title>
    <style type="text/css" media="all">
      @import url("./css/maven-base.css");
      @import url("./css/maven-theme.css");
      @import url("./css/site.css");
    </style>
    <link rel="stylesheet" href="./css/print.css" type="text/css" media="print" />
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
      </head>
  <body class="composite">
    <!-- TODO: move this into JavaScript to patch the skin
      <div class="xright">  </div>
    -->
    <div id="bodyColumn">
      <div id="contentBox">
        <div class="section"><h2>&#xfeff; DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.<a name="a_DO_NOT_ALTER_OR_REMOVE_COPYRIGHT_NOTICES_OR_THIS_HEADER."></a></h2><p>Copyright (c) 2010-2011 Oracle and/or its affiliates. All rights reserved.</p><p>The contents of this file are subject to the terms of either the GNU General Public License Version 2 only (&quot;GPL&quot;) or the Common Development and Distribution License(&quot;CDDL&quot;) (collectively, the &quot;License&quot;). You may not use this file except in compliance with the License. You can obtain a copy of the License at https://glassfish.dev.java.net/public/CDDL+GPL_1_1.html or packager/legal/LICENSE.txt. See the License for the specific language governing permissions and limitations under the License.</p><p>When distributing the software, include this License Header Notice in each file and include the License file at packager/legal/LICENSE.txt.</p><p>GPL Classpath Exception: Oracle designates this particular file as subject to the &quot;Classpath&quot; exception as provided by Oracle in the GPL Version 2 section of the License file that accompanied this code.</p><p>Modifications: If applicable, add the following below the License Header, with the fields enclosed by brackets [] replaced by your own identifying information: &quot;Portions Copyright [year] [name of copyright owner]&quot;</p><p>Contributor(s): If you wish your version of this file to be governed by only the CDDL or only the GPL Version 2, indicate your decision by adding &quot;[Contributor] elects to include this software in this distribution under the [CDDL or GPL Version 2] license.&quot; If you don't indicate a single choice of license, a recipient has the option to distribute your version of this file under either the CDDL, the GPL Version 2 or to extend the choice of license to its licensees as provided above. However, if you add GPL Version 2 code and therefore, elected the GPL Version 2 license, then the option applies only if the new code is made subject to such option by the copyright holder.</p></div><div class="section"><h2>Introduction<a name="Introduction"></a></h2><p>With the HK2 module system, the module system is already responsible for instantiating many classes that constitute the application functionality.</p><p>HK2 components runtime will complement the module system so that it creates objects, but it configures such objects by:</p><ul><li>injecting other objects that are needed by a newly instantiated object.</li><li>injecting configuration information needed for that object.</li><li>making newly created objects available, so that it can be then injected to other objects that need it.</li></ul></div><div class="section"><h2>Services<a name="Services"></a></h2><p>HK2 relies on the notion of Service to identify the building blocks or the extension points of an application. Services are just POJO :</p><ul><li>implementing an interface</li><li>declared in jar with the META-INF/services file<p>To clearly separate the contract interface and its implementation, the HK2 runtime needs to understand what interfaces are contract and what implementations of such interfaces are services, so this call for an annotation describing interfaces as a service contract.</p><div class="source"><pre>@Retention(RUNTIME)
@Target(TYPE)
public @interface Contract {   
}</pre></div><p>Implementations of such contract should also be annotated with an annotation so the HK2 runtime can identify them as contracts implementations.</p><div class="source"><pre>@Retention(RUNTIME)
@Target(TYPE)
public @interface Service {
...
}</pre></div><p>see <a href="./auto-depends/apidocs/org/jvnet/hk2/annotations/Service.html">Service</a> for complete reference</p></li></ul><div class="section"><h3>Runtime<a name="Runtime"></a></h3><p>Once Services are defined, HK2 runtime can be used to instantiate or retrieve instances of services. Each service instance can be scoped to be Singleton, per thread, per application or custom. This allow for greater flexibility.</p><div class="section"><h4>Scopes<a name="Scopes"></a></h4><p>Scopes are services themselves, so they can be custom defined and added to the HK2 runtime before being used by other services. Each scope is responsible for storing the services instances which are tied to itself, therefore HK2 runtime does not rely on predefined scopes (although it comes with a few predefined ones).</p><div class="source"><pre>@Contract
public abstract class Scope {
    public abstract ScopeInstance current();
}</pre></div><p>Example of scoping for service to the predefined <a href="./hk2-api/apidocs/org/glassfish/hk2/scopes/Singleton.html">Singleton</a> Scope</p><div class="source"><pre>@Service
public Singleton implements Scope {
...
}

@Scope(Singleton.class)
@Service
public class SingletonService implements RandomContract {
...
}</pre></div><p>For the curious reader, you can experiment defining a new Scope implementation and have that scope used on your @Service implementations. You will see that the HK2 runtime use the Scope instance to store/retrieve services instances tied to that scope.</p></div><div class="section"><h4>Instantiation<a name="Instantiation"></a></h4><p>Instantiation of components</p><p>In the IoC world, components are not instantiated using a new () method call. Components are retrieved using the ComponentManager instance. The simplest way is to do that is through a getComponent(Class<i>T</i> contract) call although there are more APIs available at <a href="./auto-depends/apidocs/org/jvnet/hk2/component/ComponentManager.html">ComponentManager</a></p><div class="source"><pre>    /**
     * Obtains a reference to the component inside the manager.
     *
     * &lt;p&gt;
     * This is the &quot;new Foo()&quot; equivalent in the IoC world.
     *
     * &lt;p&gt;
     * Depending on the {@link Scope} of the component, a new instance
     * might be created, or an existing instance might be returned.
     *
     * @return
     *      non-null.
     * @throws ComponentException
     *      If failed to obtain a requested instance.
     *      In practice, failure only happens when we try to create a
     *      new instance of the component.
     */
    public &lt;T&gt; T getComponent(Class&lt;T&gt; clazz) throws ComponentException</pre></div><p>HK2 employs a &quot;lazy instantiation&quot; model. Only after demand exists for a component does that component get instantiated. Demand can come from either injection (@Inject) or through programmatic calls to the ComponentManager. Note, however, that the Scope of the service also plays a role on the instantiation of the given component.</p></div><div class="section"><h4>Lifecycle<a name="Lifecycle"></a></h4><p>Components can attach behaviors to their construction and destruction events by implementing the <a href="./auto-depends/apidocs/org/jvnet/hk2/component/PostConstruct.html">PostConstruct</a> and/or the <a href="./auto-depends/apidocs/org/jvnet/hk2/component/PreDestroy.html">PreDestroy</a> interfaces. Interfaces have been used rather than annotations for performance as it is faster to cast component instance to any of these interfaces to check if the component has implemented one of them rather than using reflection on all methods to find if they are annotated.</p></div></div><div class="section"><h3>Run Level Based Lifecycle<a name="Run_Level_Based_Lifecycle"></a></h3><p>Components can also use a <a href="./hk2-api/apidocs/org/jvnet/hk2/annotations/RunLevel">RunLevel</a> form of lifecycle. As stated previously, HK2 employs a &#x201c;lazy instantiation&#x201d; model for component creation. However, there are situations where the developer may want the instantiation to occur either immediately upon HK2 initialization or otherwise on some more regimented schedule.</p><p>see <a href="./runlevelservices.html">run level services</a> for complete reference</p></div></div><div class="section"><h2>Inversion of Control<a name="Inversion_of_Control"></a></h2><div class="section"><h3>Injection<a name="Injection"></a></h3><p>Services usually rely of other services to perform their tasks and the model described above can easily be extended to have the HK2 runtime identify the @Contract implementations required by a service. This call for a new annotation <a href="./auto-depends/apidocs/org/jvnet/hk2/annotations/Inject.html">Inject</a> which can be placed on fields or setter methods of any Service instantiated by the HK2 runtime and have that Service retrieved and injected during the service's instantiation by the component manager.</p><div class="source"><pre>Field :
@Inject
ConfigService config;

Setter method :
@Inject
public void set(ConfigService svc) {..}</pre></div><p>Injection can further qualify the intended injected service implementation by using a name and scope from which the service should be available.</p><div class="source"><pre>@Inject(Scope=Singleton.class, name=&quot;deploy&quot;)
AdminCommand deployCommand;</pre></div></div><div class="section"><h3>Instantiation Cascading<a name="Instantiation_Cascading"></a></h3><p>Injection of instances which have not been already instantiated triggers more instantiation. In a sense, you can see this as a components instantiation cascading where some code requests for a high level Service will in turn throuh @Inject annotation requires more injection/instantiation of lower level Services. This important feature is a great tool to keep the implementation as private as possible while relying on interfaces and separation of contract/providers.</p><p>Below is the example of how the instantiation of DeploymentService as a Startup contract implementation will trigger the instantiation of the ConfigService.</p><div class="source"><pre>@Contract
public interface Startup {...}

Iterable&lt;Startup&gt; startups;
startups = componentMgr.getComponents(Startup.class);

@Service
public class DeploymentService implements Startup {

    @Inject
    ConfigService config;
}

@Service
public Class ConfigService implements ... {...}
</pre></div></div></div>
      </div>
    </div>
    <div class="clear">
      <hr/>
    </div>
    <div id="footer">
      <div class="xright">&#169;  
          2011
    
          Oracle Corporation
          
  

  
  
  &nbsp;| Last Published: 09/07/2011
  &nbsp;| Version: 1.6.18-SNAPSHOT
</div>
      <div class="clear">
        <hr/>
      </div>
    </div>
  </body>
</html>
