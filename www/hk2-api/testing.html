<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">










<html>
  <head>
    <title>HK2 Testing with JUnit.</title>
    <style type="text/css" media="all">
      @import url("./css/maven-base.css");
      @import url("./css/maven-theme.css");
      @import url("./css/site.css");
    </style>
    <link rel="stylesheet" href="./css/print.css" type="text/css" media="print" />
          <meta name="author" content="Jerome Dochez" />
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
      </head>
  <body class="composite">
    <!-- TODO: move this into JavaScript to patch the skin
      <div class="xright">  </div>
    -->
    <div id="bodyColumn">
      <div id="contentBox">
        <p>Any hk2-jar or jar maven module importing hk2 can develop junit tests that will be injected with resources available in the hk2 habitat.</p><div class="section"><h2>Maven project requirements.<a name="Maven_project_requirements."></a></h2><p>If your project type is hk2-jar, you have nothing to do. When using a plain maven jar module, you must add the following dependency in your pom.xml</p><div class="source"><pre>        &lt;dependency&gt;
            &lt;groupId&gt;junit&lt;/groupId&gt;
            &lt;artifactId&gt;junit&lt;/artifactId&gt;
            &lt;version&gt;4.5&lt;/version&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.sun.enterprise&lt;/groupId&gt;
            &lt;artifactId&gt;auto-depends&lt;/artifactId&gt;
            &lt;version&gt;..hk2 version ...&lt;/version&gt;
        &lt;/dependency&gt;</pre></div><p>The structure of a normal maven projects applies :</p><div class="source"><pre>./pom.xml
./src
./src/main
./src/main/java
   [ put all your module services and contract definition as you expect them to be used ]
./src/test
./src/test/java
   [ put all your junit tests and mockup services implementation ]</pre></div></div><div class="section"><h2>Example<a name="Example"></a></h2><div class="section"><h3>Contract definition<a name="Contract_definition"></a></h3><p>put your contract definition :</p><div class="source"><pre>package org.glassfish.hk2.junit.samples.simple;

import org.jvnet.hk2.annotations.Contract;

/**
 * Simple contract definition
 */
@Contract
public interface RandomContract {

    /**
     * Adds the two paramters and return the result
     * @param i the first element to add
     * @param j the second
     * @return the addition of i and j
     */
    int add(int i, int j);
}</pre></div><p>in the usual location :</p><p>./src/main/java/org/glassfish/hk2/junit/samples/simple/tests/RandomContractTest.java</p></div><div class="section"><h3>Service implementation<a name="Service_implementation"></a></h3><div class="source"><pre>package org.glassfish.hk2.junit.samples.simple.org.glassfush.hk2.junit.samples.simple.impl;

import org.glassfish.hk2.junit.samples.simple.RandomContract;
import org.jvnet.hk2.annotations.Service;

/**
 * Random contract implementation
 */
@Service
public class RandomService implements RandomContract {
    public int add(int i, int j) {
        return i+j;
    }
}</pre></div><p>in the usual location :</p><p>./src/main/java/org/glassfish/hk2/junit/samples/simple/impl/RandomService.java</p></div><div class="section"><h3>Test definition<a name="Test_definition"></a></h3><div class="source"><pre>package org.glassfish.hk2.junit.samples.simple.tests;

import org.glassfish.hk2.junit.samples.simple.RandomContract;
import org.junit.Assert;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.jvnet.hk2.annotations.Inject;
import org.jvnet.hk2.junit.Hk2Runner;

/**
 * Simple test of RandomContract
 */
@RunWith(Hk2Runner.class)
public class RandomContractTest {

    @Inject
    RandomContract myService;

    @Test
    public void twoPlusTwo() {
        int result = myService.add(2,2);
        Assert.assertTrue(result==4);
    }
}</pre></div><p>in the usual test location :</p><p>./src/test/java/org/glassfish/hk2/junit/samples/simple/tests/RandomContractTest.java</p></div></div><div class="section"><h2>Mockup services<a name="Mockup_services"></a></h2><p>Obviously, you sometimes need to develop mock up implementations of some services that will be used directly by your test or by a service of your module. Say you have the following contract definition :</p><div class="source"><pre>/**
 * an important contract that cannot necessarily be instantiated during unit tests
 *
 */
@Contract
public interface ImportantContract {

    public String getUserNameFromSecureDB();

    public String getCompleteName();

}</pre></div><p>Now some other service inside your module (not necessarily a test) :</p><div class="source"><pre>@Service
public class ServiceUser {
    @Inject
    ImportantContract imp;

    public String tellMe() {
        return &quot;Bonjour &quot; + imp.getCompleteName();
    }
}</pre></div><p>somewhere in src/main/java.</p><p>Now you don't have an implementation of this ImportantContract contract in your modules source. But you can have a mock up implementation in your unit test source directory to satisfy the dependency and be able to test the system as a whole, like if the contract was available.</p><div class="source"><pre>@Service
public class ImportantContractHardCoded implements ImportantContract {

    @Inject
    RandomContract sub;

    public String getUserNameFromSecureDB() {
        return &quot;Dochez&quot;;
    }

    public String getCompleteName() {
        return sub.concatenate(&quot;Jerome&quot;, &quot;Dochez&quot;);
    }
}</pre></div><p>inside src/test/java/org/glassfish/hk2/junit/samples/simple/tests/mockup/ImportantContractHardCoded.java</p><p>and now your test is simple enough :</p><div class="source"><pre>@RunWith(Hk2Runner.class)
public class ServiceUserTest {

    @Inject
    ServiceUser su;

    @Test
    public void userTest() {
        System.out.println(su.tellMe());
    }
}</pre></div><p>Since your mockup implementation is part of src/test/java, it will not be shipped with your module binary and pollute the product habitat.</p><p>Manually adding services to the Servics. Sometimes, it is necessary to manually add services to the habitat (or swap existing ones with mockup versions) Look at the @BeforeClass annotated method that register a few extra services to satisfy dependency.</p><div class="source"><pre>@RunWith(Hk2Runner.class)
public class CommandRunnerTest {

    @Inject
    CommandRunner commandRunner;

    @BeforeClass
    public static void setup() {
        Services services = Hk2Runner.getServices();

        DynamicBinderFactory binder = services.bindDynamically();
        binder.bind().to(new StartupContext());
        binder.bind(ModulesRegistry.class).to(new SingleModulesRegistry(CommandRunnerTest.class.getClassLoader());
        binder.commit();
    }


    @Test
    public void tryOut() {
        Assert.assertTrue(commandRunner!=null);
        try {
            ActionReport report = commandRunner.getActionReport(&quot;plain&quot;);
            CommandRunner.CommandInvocation inv = commandRunner.getCommandInvocation(&quot;list-contracts&quot;, report);
            inv.execute();
            System.out.println(report.getTopMessagePart().getMessage());
            for (ActionReport.MessagePart child : report.getTopMessagePart().getChildren()) {
                System.out.println(child.getMessage());
            }
        } catch(Exception e) {
            e.printStackTrace();
        }
    }
}</pre></div><div class="section"><h3>How does it work ?<a name="How_does_it_work_"></a></h3><p>I use a special JUnit runner to run the test and inject them. Not all the junit features are available with the new Runner, if you run into issues, please ping me. Also the tests compilation does not generate the META-INF/inhabitant/default file, I use an new introspection facility to populate the habitat from the .class files directly. The test execution class path is used to build the habitat, each class path element must be either a jar or a directory. If that element contains a META-INF/inhabitant file, it is used otherwise the system will introspect the jar or directory. If the jar is an OSGi bundle and the hk2 packages are not imported, the module will not be introspected for HK2 services.</p></div></div>
      </div>
    </div>
    <div class="clear">
      <hr/>
    </div>
    <div id="footer">
      <div class="xright">&#169;  
          2012
    
          Oracle Corporation
          
  

  
  
  &nbsp;| Last Published: 04/25/2012
  &nbsp;| Version: 2.1.0-SNAPSHOT
</div>
      <div class="clear">
        <hr/>
      </div>
    </div>
  </body>
</html>
