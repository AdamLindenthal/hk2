<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">










<html>
  <head>
    <title>Introduction to Modularity with HK2</title>
    <style type="text/css" media="all">
      @import url("./css/maven-base.css");
      @import url("./css/maven-theme.css");
      @import url("./css/site.css");
    </style>
    <link rel="stylesheet" href="./css/print.css" type="text/css" media="print" />
          <meta name="author" content="Jerome Dochez" />
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
      </head>
  <body class="composite">
    <!-- TODO: move this into JavaScript to patch the skin
      <div class="xright">  </div>
    -->
    <div id="bodyColumn">
      <div id="contentBox">
        <p>Compatibility note to earlier HK2 developers : Habitat has been replaced with a new interface <a href="./apidocs/org/glassfish/hk2/Services.html">Services</a> and an associated DSL for adding and querying services. More information <a href="./index.html">here</a>.</p><p>Although people can use the layering of services instances offered by the <a href="./apidocs/org/glassfish/hk2/Services.html">Services</a> interfaces coupled with strict programmatic visibility expressions between instances of services, most development use modules (jar files) as a way to distribute optional software parts to form a runtime environment as described <a href="./index.html">here</a>.</p><p>The runtime environment or the default <a href="./apidocs/org/glassfish/hk2/Services.html">Services</a> instance , will be constructed with the union of all the <a href="./apidocs/org/jvnet/hk2/annotations/Contract.html">Contract</a> implementations and will be used by the HK2 machinery to resolve <a href="./apidocs/org/jvnet/hk2/annotations/Inject.html">Inject</a> dependencies or explicit lookup via APIs.</p><p>Therefore, the usual HK2 deployment is a flat namespace where all the services are part of a single Services instance (aka Habitat). The namespace will be populated with all the services declared in the configured hk2 jar files. The configured jar files can be a set of directories (repositories of modules) or can be added programmatically or in the case of the embedded mode, the jars present on the classpath. For instance, in GlassFish, by default all jars present in a special directory like ~glassfish/modules are used to configure the HK2 Runtime.</p><p>So you can see that by adding/removing hk2 jar from that repository of modules, the set of services available for resolving dependencies can vary, such property can be used to deliver software with different capabilities by changing the set of modules delivered. Let's walk through a set of examples to clarify :</p><ul><li>Simple Substitution : a particular service implementation (capability) has a different implementation for each product.</li><li>Optional dependency : a particular service is available in certain products and may be missing in others.</li><li>Configuration driven dependencies : depending on the configuration of a product, a particular implementation of a service should be used.</li><li>Subclassing : a product implementation has one version, another version has a subclass of the first.</li></ul><div class="section"><h2>Simple substitution<a name="Simple_substitution"></a></h2><p>In this case, a particular version of a product is shipping one version of a Service while another version of the same product is shipping a different version. Please note that one implementation of that service must exist in any product. The first thing to do is to clarify very well the SPI this service implements, and define that SPI as an interface annotated with the <a href="./apidocs/org/jvnet/hk2/annotations/Contract.html">Contract</a> annotation.</p><div class="source"><pre>@Contract
public interface MyContract {

    /**
     * Document me well
     */
     void doSomething();
}</pre></div><p>Package this interface in a module that will be shipped with both products (let's call it services-api.jar).</p><div class="section"><h3>Service utilization<a name="Service_utilization"></a></h3><p>Whether code that wants to use the MyContract service resides in the common code to Product A or B, in the code specific to product A or B, it should have access to the service implementation using one the following technique</p><div class="section"><h4>Declarative Dependency<a name="Declarative_Dependency"></a></h4><p>By using the <a href="./apidocs/org/jvnet/hk2/annotations/Inject.html">Inject</a> annotation, the code can declare to the system a requirement on a particular service implementation. Such declaration will force the HK2 dependency management subsystem to inject the resolved MyContract implementation in the instance variable.</p><div class="source"><pre>@Service
public class SomeUserCode {

    @Inject
    MyContract contractImpl;
}</pre></div><p>Another way is to use constructor injection :</p><div class="source"><pre>@Service
public class SomeUserCode {

    final MyContract contractImpl;

    SomeUserCode(@Inject MyContract impl) {
        this.contractImpl = impl;
    }
}</pre></div></div><div class="section"><h4>Explicit API lookup.<a name="Explicit_API_lookup."></a></h4><p>Provided the user's code has access to the <a href="./apidocs/org/glassfish/hk2/Services.html">Services</a> instance, it can do an explicit service lookup :</p><div class="source"><pre>    MyContract myContractImpl = services.forContract(MyContract.class).get();
    myContractImpl.doSomething();</pre></div></div></div><div class="section"><h3>Implementation Packaging<a name="Implementation_Packaging"></a></h3><p>In this simple substitution mode, the products will package at least one service or another but never the two of them. The simplest way of achieving that result is to define a productA-impl.jar and productB-impl.jar, each containing the service implementation and ensure that only one jar is shipped in the final product.</p></div></div><div class="section"><h2>Optional Dependency<a name="Optional_Dependency"></a></h2><p>In this mode, a service may be present or absent. It should be used when present but no failure should be generated by its absence.</p><div class="section"><h3>Optional declarative dependency<a name="Optional_declarative_dependency"></a></h3><div class="source"><pre>@Service
public class SomeUserCode {

    @Inject(optional=true)
    MyContract optionalContract = null;


    public void someMethod() {

        if (optionalContract!=null) {
            optionalContract.doSomething();
        }
    }
}
</pre></div></div><div class="section"><h3>Optional dependency API lookup<a name="Optional_dependency_API_lookup"></a></h3><p>Very similar to the previous case, the explicit lookup should just take into account that a null value can be returned.</p><div class="source"><pre>    MyContract myContractImpl = services.forContract(MyContract.class).get();
    if (myContractImpl!=null) {
        myContractImpl.doSomething();
    }</pre></div></div><div class="section"><h3>Packaging<a name="Packaging"></a></h3><p>Optional services should be packaged in a separate jar that does not contain any required services implementation or contract definitions.</p></div></div><div class="section"><h2>Config Based Dependency<a name="Config_Based_Dependency"></a></h2><p>Sometimes, several competing implementations of a service exist and some configuration should trigger which particular implementation should be use. These implementations need to be differentiated and that can be achieved by naming each implementation with a different name (String based) or using annotations (Type based).</p><div class="section"><h3>String based<a name="String_based"></a></h3><p>To add a string based name to a contract implementation, use the <a href="./apidocs/org/jvnet/hk2/annotations/Service.html">Service</a> name.</p><div class="source"><pre>@Service(name=&quot;foo&quot;)
public class MyContractImpl {

    public void doSomething() {

    }
}</pre></div><p>Another implementation can then name its implementation different.</p><div class="source"><pre>@Service(name=&quot;bar&quot;)
public class MyContractImpl {

    public void doSomething() {

    }
}</pre></div><p>while to look up will need to use the HK2 APIs to do an explicit lookup.</p><div class="source"><pre>    String serviceName = ... get the service name from config/system property/code ...

    // hopefully service name is either &quot;foo&quot; or &quot;bar&quot;
    MyContract myContractImpl = services.forContract(MyContract.class).named(serviceName).get();
    // you should always check you got what you wanted.
    if (myContractImpl!=null) {
        myContractImpl.doSomething();
    }</pre></div></div><div class="section"><h3>Annotation based.<a name="Annotation_based."></a></h3><p>More type safe but not always as flexible, services implementation can be disambiguated using annotations :</p><div class="source"><pre>@Service
@Basic
public class MyContractImpl {

    public void doSomething() {

    }
}</pre></div><p>Another implementation can then name its implementation different.</p><div class="source"><pre>@Service
@Extended
public class MyContractImpl {

    public void doSomething() {

    }
}</pre></div><p>while to look up will need to use the HK2 APIs to do an explicit lookup.</p><div class="source"><pre>    Class&lt;? extends Annotation&gt; annotationType = ... get it from config ...

    // hopefully service name is either &quot;foo&quot; or &quot;bar&quot;
    MyContract myContractImpl = services.forContract(MyContract.class).annotatedWith(annotationType).get();
    // you should always check you got what you wanted.
    if (myContractImpl!=null) {
        myContractImpl.doSomething();
    }</pre></div><p>of course, nothing prevents you from doing an explicit typed lookup.</p><div class="source"><pre>    MyContract myContractImpl = services.forContract(MyContract.class).annotatedWith(Extended.class).get();

    or

    @Inject
    @Extended
    MyContract myContract;</pre></div></div></div><div class="section"><h2>Subclassing<a name="Subclassing"></a></h2><p>The casual reader might think that using the last methods (Substitution, Configuration) would work but it has major drawbacks, let's look at an example.</p><div class="source"><pre>@Service(name=&quot;super&quot;)
public class MyContractImpl {

    public void doSomething() {

    }
}
@Service(name=&quot;child&quot;)
public class MyContract2Impl extends MyContractImpl {

    @Override
    public void doSomething() {
        super.doSomething();
        // do something else
    }
}</pre></div><p>The first issue force every client to know if which environment it is operating so it lookups the right implementation using a hardcoded name. Obviously you want to have the client code to be un-aware if it is running in particular product.</p><p>You could try to do the substitution method but it does not work either since you need the superclass definition in all cases (because of the subclassing).</p><p>The simplest solution to this problem is to introduce a level of indirection, adding an abstract class that contains all the common code while having 2 subclasses. The first subclass will be a tag class, probably empty that will declare the service for the first product. The other subclass will also be annotated with @Service and will be containing the second product specific code.</p><div class="source"><pre>// note this class is NOT annotated with @Service
public abstract class AbstractMyContractImpl implements MyContract {
    public void doSomething() {
        ... interesting code ...
    }
}


@Service
public class MyContractImpl extends AbstractMyContractImpl {
}

@Service
public class MyContract2Impl extends AbstractMyContractImpl {

    @Override
    public void doSomething() {
        super.doSomething();
        // do something else
    }
}</pre></div><div class="section"><h3>Dependency declaration<a name="Dependency_declaration"></a></h3><p>The normal declarative or programmatic access to the implementation is similar to case 1, since only one of the two @Service annotated class will be shipped in a particular product.</p><div class="source"><pre>@Service
public class SomeUserCode {

    @Inject
    MyContract contractImpl;
}</pre></div></div><div class="section"><h3>Packaging<a name="Packaging"></a></h3><p>In order to meet the requirements of visibility, 3 modules are needed.</p><ul><li>common-impl.jar : will be packaging all common code to product A and B.</li><li>productA-impl.jar : contains the product A specific @Service classes (MyContractImpl.class in the example above).</li><li>productB-impl.jar : contains the product B spcecific @Service classes (MyContract2Impl above).</li></ul></div></div>
      </div>
    </div>
    <div class="clear">
      <hr/>
    </div>
    <div id="footer">
      <div class="xright">&#169;  
          2012
    
          Oracle Corporation
          
  

  
  
  &nbsp;| Last Published: 01/04/2012
  &nbsp;| Version: 1.6.28-SNAPSHOT
</div>
      <div class="clear">
        <hr/>
      </div>
    </div>
  </body>
</html>
