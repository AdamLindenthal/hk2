<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">










<html>
  <head>
    <title>Introduction to HK2</title>
    <style type="text/css" media="all">
      @import url("./css/maven-base.css");
      @import url("./css/maven-theme.css");
      @import url("./css/site.css");
    </style>
    <link rel="stylesheet" href="./css/print.css" type="text/css" media="print" />
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
      </head>
  <body class="composite">
    <!-- TODO: move this into JavaScript to patch the skin
      <div class="xright">  </div>
    -->
    <div id="bodyColumn">
      <div id="contentBox">
        <div class="section"><h2>Compatibility<a name="Compatibility"></a></h2><p>This page describes the HK2 2.0 API, which is based on JSR-330 standard annotations. Also, Habitat has been replaced with a new interface called <a href="./apidocs/org/glassfish/hk2/api/ServiceLocator.html">ServiceLocator</a>.</p></div><div class="section"><h2>Table of Contents<a name="Table_of_Contents"></a></h2><ul><li><a href="#Introduction">Introduction</a></li><li><a href="#Getting_Started">Getting Started</a><ul><li><a href="#Named_Services">Named Services</a></li><li><a href="#Qualified_Services">Qualified Services</a></li></ul></li><li><a href="#Basic_Injection">Basic Injection</a><ul><li><a href="#Injection_by_name">Injection by name</a></li><li><a href="#Injection_by_qualifier">Injection by qualifier</a></li></ul></li><li><a href="#Provider_injection">Provider injection</a></li><li><a href="#IterableProvider_injection">IterableProvider injection</a></li><li><a href="#Conclusion">Conclusion</a></li></ul></div><div class="section"><h2><a name="Introduction">Introduction</a></h2><p>HK2 is a declarative framework for services using annotations like <a href="./apidocs/org/jvnet/hk2/annotations/Contract.html">Contract</a> and <a href="./apidocs/org/jvnet/hk2/annotations/Service.html">Service</a>. This page is intended to show simple usages of HK2 mainly using the standard JSR-330 API.</p><p>For information about using the HK2 progrommatic API see <a href="./api.html">this page</a>.</p><p>For information about HK2 extensibility options see <a href="./extensibility.html">this page</a>.</p><p>For information about JSR-330 see <a class="externalLink" href="http://www.jcp.org/en/jsr/detail?id=330">this site</a>.</p><p>This page assumes that you are using the HK2 provided ability to automatically find and register services in an HK2 registry. For more information on how to control what services are automatically bound to what registries see TBD.</p></div><div class="section"><h2><a name="Getting_Started">Getting Started</a></h2><p>In order to mark a concrete implementation class as one that should be available as a service you annotate your class with <a href="./apidocs/org/jvnet/hk2/annotations/Service.html">@Service</a>.</p><div class="source"><pre>@Service
public class Foo {
}</pre></div><p>By default Foo will be advertised as itself and by any interfaces that are marked with <a href="./apidocs/org/jvnet/hk2/annotations/Contract.html">@Contract</a>. Lets make Foo an interface that is a Contract and create an implementation of Foo:</p><div class="source"><pre>@Contract
public interface Foo {
}

@Service
public class FooImpl implements Foo {
}</pre></div><p>The FooImpl class will be placed into the registry advertised under both FooImpl and Foo.</p><div class="section"><h3><a name="Named_Services">Named Services</a></h3><p>In order to differentiate different implementations of the same interface you can name your services. Here is an example of a class that implements a contract and has two implementations, both named differently:</p><div class="source"><pre>@Contract
public interface Book {
}

@Service @Named
public class MobyDick implements Book {
}

@Service @Named
public class ParadiseLost implements Book {
}</pre></div><p>The two classes, MobyDick and ParadiseLost, will be added to the service registry with the names &quot;MobyDick&quot; and &quot;ParadiseLost&quot;. If you use the <a class="externalLink" href="http://docs.oracle.com/javaee/6/api/javax/inject/Named.html">Named</a> qualifier without specifying a name then the name you get is the class name without the package.</p></div><div class="section"><h3><a name="Qualified_Services">Qualified Services</a></h3><p>Services can also be qualified with annotations called qualifiers. Qualifiers are annotations that are themselves annotated with <a class="externalLink" href="http://docs.oracle.com/javaee/6/api/javax/inject/Qualifier.html">@Qualifier</a>. Here is an example contract with three implementations:</p><div class="source"><pre>@Contract
public interface Color {
}

@Service @Blue
public class BlueColor implements Color {
}

@Service @Red
public class RedColor implements Color {
}

@Service @Yellow
public class YellowColor implements Color {
}</pre></div><p>The Blue annotation is defined like this:</p><div class="source"><pre>@Qualifier
@Retention(RUNTIME)
@Target( { TYPE, METHOD, FIELD, PARAMETER })
public @interface Blue {
}</pre></div><p>It is an exercise left up to the reader to implement the Red and Yellow annotations.</p></div></div><div class="section"><h2><a name="Basic_Injection">Basic Injection</a></h2><p>Lets make our example a little more interesting by injecting a book into Foo. This is done using the JSR-330 standard <a class="externalLink" href="http://docs.oracle.com/javaee/6/api/javax/inject/Inject.html">Inject</a> annotation:</p><div class="source"><pre>@Service
public class FooImpl implements Foo {
  @Inject
  private Book book;
  
  ...
}</pre></div><p>Upon construction the book field will be filled in by HK2. You can also inject into the constructor of FooImpl, or use an initializer method. In both of those cases the constructor or method must be annotated with <a class="externalLink" href="http://docs.oracle.com/javaee/6/api/javax/inject/Inject.html">@Inject</a> in order to tell HK2 which is the proper constructor or method to call.</p><p>Here is FooImpl implemented with constructor injection:</p><div class="source"><pre>@Service
public class FooImpl implements Foo {
  private final Book book;
  
  @Inject
  public FooImpl(Book book) {
      // constructor injected!
      this.book = book;
  }
}</pre></div><p>Here is FooImpl implemented with initializer method injection:</p><div class="source"><pre>@Service
public class FooImpl implements Foo {
  private Book book;
  
  @Inject
  public void setBook(Book book) {
      // initializer method injected!
      this.book = book;
  }
}</pre></div><p>In all three of the above cases (field injected, constructor injected or initializer method injected) the injection will occur prior to the postConstruct method of FooImpl. In this example we use the injected book in the postConstruct method:</p><div class="source"><pre>@Service
public class FooImpl implements Foo {
  @Inject
  private Book book;
  
  @PostConstruct
  private void postConstruct() {
      book.doSomething();
  }
}</pre></div><div class="section"><h3><a name="Injection_by_name">Injection by name</a></h3><p>The astute observer of our example will have noticed that when injecting a Book into FooImpl that we never selected which book we wanted. That can be fixed by using the <a class="externalLink" href="http://docs.oracle.com/javaee/6/api/javax/inject/Named.html">Named</a> qualifier at the point of injection. Lets fix the example by injecting both of the Books we defined earlier:</p><div class="source"><pre>@Service
public class FooImpl implements Foo {
  @Inject @Named(&quot;MobyDick&quot;)
  private Book mobyDick;
  
  @Inject @Named(&quot;ParadiseLost&quot;)
  private Book paradiseLost;
}</pre></div><p>The implementation of Book given the name &quot;MobyDick&quot; will be injected into the mobyDick field, and the implementation of Book given the name &quot;ParadiseLost&quot; will be injected into the paradiseLost field.</p></div><div class="section"><h3><a name="Injection_by_qualifier">Injection by qualifier</a></h3><p>Injections can also be more specifically chosen by using qualifiers. In the previous example we created three implementations of Color, each of which was qualified with a qualifier. Here we create a class called ColorMixer which injects the colors in an initializer method, which also demonstrates that an initializer method (or constructor) can take more than one parameter:</p><div class="source"><pre>@Service
public class ColorMixer {
    private Color red;
    private Color blue;
    private Color yellow;
  
    @Inject
    private void addPrimaries(
            @Red Color red,
            @Blue Color blue,
            @Yellow Color yellow) {
      this.red = red;
      this.blue = blue;
      this.yellow = yellow;
   }
}</pre></div><p>Note that the qualifiers can go on the parameters of the initializer method addPrimaries. In the above example the RedColor, BlueColor and YellowColor services will be injected into the proper fields of the initializer.</p></div></div><div class="section"><h2><a name="Provider_injection">Provider injection</a></h2><p>There are times when your code would like finer control over when a instance of a service is created. Anywhere that you can inject a service, you can also inject a <a class="externalLink" href="http://atinject.googlecode.com/svn/trunk/javadoc/javax/inject/Provider.html">Provider</a>. When you inject a <a class="externalLink" href="http://atinject.googlecode.com/svn/trunk/javadoc/javax/inject/Provider.html">Provider</a> for a service rather than the service itself the system will potentially delay the creation of the service until the <a class="externalLink" href="http://atinject.googlecode.com/svn/trunk/javadoc/javax/inject/Provider.html#get%28%29">get</a> method of the <a class="externalLink" href="http://atinject.googlecode.com/svn/trunk/javadoc/javax/inject/Provider.html">Provider</a> has been called.</p><p>Lets go back to our ColorMixer example, and inject providers (into fields this time) for our primaries.</p><div class="source"><pre>@Service
public class ColorMixer {
    @Inject @Red
    private Provider&lt;Color&gt; redProvider;
    
    @Inject @Blue
    private Provider&lt;Color&gt; blueProvider;
    
    @Inject @Yellow
    private Provider&lt;Color&gt; yellowProvider;
}</pre></div><p>This service can then get the color implementations later. In this method of ColorMixer we create purple by getting the red and blue colors:</p><div class="source"><pre>@Service
public class ColorMixer {
    ...
    
    public Color makePurple() {
      return mix(redProvider.get(), blueProvider.get());
    }
}</pre></div><p>Note that if no-one ever makes a color that involves using yellow, that the YellowColor implementation class will never be created, since no-one ever called the <a class="externalLink" href="http://atinject.googlecode.com/svn/trunk/javadoc/javax/inject/Provider.html#get%28%29">get</a> method of the yellowProvider field.</p></div><div class="section"><h2><a name="IterableProvider_injection">IterableProvider injection</a></h2><p>It is often the case that a single contract has more than one implementation. Sometimes it is useful to get access to all of the implementations of the contract. This can be done by using an <a href="./apidocs/org/glassfish/hk2/api/IterableProvider.html">IterableProvider</a>. <a href="./apidocs/org/glassfish/hk2/api/IterableProvider.html">IterableProvider</a> extends <a class="externalLink" href="http://atinject.googlecode.com/svn/trunk/javadoc/javax/inject/Provider.html">Provider</a> and also implements <a class="externalLink" href="http://docs.oracle.com/javase/6/docs/api/java/lang/Iterable.html">Iterable</a>. Anywhere a service can be injected an <a href="./apidocs/org/glassfish/hk2/api/IterableProvider.html">IterableProvider</a> for that service can be injected.</p><p>In this example we create a Library service that wants to be able to list all of the books it carries:</p><div class="source"><pre>@Service
public class Library {
    @Inject
    private IterableProvider&lt;Book&gt; allBooks;
    
    public LinkedList&lt;Book&gt; getAllBooks() {
        LinkedList&lt;Book&gt; retVal = new LinkedList&lt;Book&gt;();
        
        for (Book book : allBooks) {
            retVal.add(book);
        }
        
        return retVal;
    }
}</pre></div><p>Since <a href="./apidocs/org/glassfish/hk2/api/IterableProvider.html">IterableProvider</a> implements <a class="externalLink" href="http://docs.oracle.com/javase/6/docs/api/java/lang/Iterable.html">Iterable</a> it can be used in Java for/while loops, as demonstrated in the above example.</p><p>Another feature of the <a href="./apidocs/org/glassfish/hk2/api/IterableProvider.html">IterableProvider</a> is that it can be used to further narrow down the selection criteria at run time. In our above example we can progrommatically choose the book we are interested in based on a name passed into a method. Here is how it would look:</p><div class="source"><pre>@Service
public class Library {
    @Inject
    private IterableProvider&lt;Book&gt; allBooks;
    
    public Book findBook(String name) {
        return allBooks.named(name).get();
    }
}</pre></div><p>In the above example we call the <a class="externalLink" href="http://hk2.java.net/hk2-api/apidocs/org/glassfish/hk2/api/IterableProvider.html#named%28java.lang.String%29">named</a> method of <a href="./apidocs/org/glassfish/hk2/api/IterableProvider.html">IterableProvider</a> in order to select the book with the given name. The call to <a class="externalLink" href="http://atinject.googlecode.com/svn/trunk/javadoc/javax/inject/Provider.html#get%28%29">get</a> then just returns the book with the given name.</p></div><div class="section"><h2><a name="Conclusion">Conclusion</a></h2><p>The majority of usages of HK2 should use standard JSR-330 annotations along with <a href="./apidocs/org/jvnet/hk2/annotations/Service.html">@Service</a> and <a href="./apidocs/org/jvnet/hk2/annotations/Contract.html">@Contract</a>. In some cases code will also use <a href="./apidocs/org/glassfish/hk2/api/IterableProvider.html">IterableProvider</a> as outlined above. In even rarer cases the code may need extremely specialized control over HK2 by using the progrommatic API, as described <a href="./api.html">here</a>.</p><p>We have gone through many simple examples which have shown the basic functionality of HK2 and JSR-330 in your applications. Hopefully they have provided you with knowledge about how these annotations work and how they can be used in your own applications.</p></div>
      </div>
    </div>
    <div class="clear">
      <hr/>
    </div>
    <div id="footer">
      <div class="xright">&#169;  
          2012
    
          Oracle Corporation
          
  

  
  
  &nbsp;| Last Published: 04/25/2012
  &nbsp;| Version: 2.1.0-SNAPSHOT
</div>
      <div class="clear">
        <hr/>
      </div>
    </div>
  </body>
</html>
