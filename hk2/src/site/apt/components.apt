
    DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.

    Copyright (c) 2010-2011 Oracle and/or its affiliates. All rights reserved.

    The contents of this file are subject to the terms of either the GNU
    General Public License Version 2 only ("GPL") or the Common Development
    and Distribution License("CDDL") (collectively, the "License").  You
    may not use this file except in compliance with the License.  You can
    obtain a copy of the License at
    https://glassfish.dev.java.net/public/CDDL+GPL_1_1.html
    or packager/legal/LICENSE.txt.  See the License for the specific
    language governing permissions and limitations under the License.

    When distributing the software, include this License Header Notice in each
    file and include the License file at packager/legal/LICENSE.txt.

    GPL Classpath Exception:
    Oracle designates this particular file as subject to the "Classpath"
    exception as provided by Oracle in the GPL Version 2 section of the License
    file that accompanied this code.

    Modifications:
    If applicable, add the following below the License Header, with the fields
    enclosed by brackets [] replaced by your own identifying information:
    "Portions Copyright [year] [name of copyright owner]"

    Contributor(s):
    If you wish your version of this file to be governed by only the CDDL or
    only the GPL Version 2, indicate your decision by adding "[Contributor]
    elects to include this software in this distribution under the [CDDL or GPL
    Version 2] license."  If you don't indicate a single choice of license, a
    recipient has the option to distribute your version of this file under
    either the CDDL, the GPL Version 2 or to extend the choice of license to
    its licensees as provided above.  However, if you add GPL Version 2 code
    and therefore, elected the GPL Version 2 license, then the option applies
    only if the new code is made subject to such option by the copyright
    holder.


Introduction

    With the HK2 module system, the module system is already responsible for instanciating many classes that constitute the application functionality.

    HK2 components runtime will complement the module system so that it creates objects, but it configures such objects by:

    * injecting other objects that are needed by a newly instanciated object.

    * injecting configuration information needed for that object.

    * making newly created objects available, so that it can be then injected to other objects that need it.

Services

    HK2 relies on the notion of Service to identify the building blocks or the extension points of an application. Services are just POJO :

    * implementating an interface

    * declared in jar with the META-INF/services file

    To clearly separatethe contract interface and its implementation, the HK2 runtime needs to understand what interfaces
are contract and what implemenations of such interfaces are services, so this call for an annotation describing
interfaces as a service contract.


+-----+
@Retention(RUNTIME)
@Target(TYPE)
public @interface Contract {   
}
+-----+

    Implementations of such contract should also be annotated with an annotation so the HK2 runtime can identify them
as contracts implementations.

+-----+
@Retention(RUNTIME)
@Target(TYPE)
public @interface Service {
...
}
+-----+

    see {{{auto-depends/apidocs/org/jvnet/hk2/annotations/Service.html}Service}} for complete reference


* Runtime

    Once Services are defined, HK2 runtime can be used to instantiate or retrieve instances of services. Each service
instance can be scoped to be Singleton, per thread, per application or custom. This allow for greater flexibility.

** Scopes

    Scopes are services themselves, so they can be custom defined and added to the HK2 runtime before being used by other
 services. Each scope is responsible for storing the services instances which are tied to itself, therefore HK2 runtime
 does not rely on predefined scopes (although it comes with a few predefined ones).

+------------+
@Contract
public abstract class Scope {
    public abstract ScopeInstance current();
}
+------------+

    Example of scoping for service to the predefined {{{org.jvnet.hk2.component.Singleton.html}Singleton}} Scope

+--------------+
@Service
public Singleton implements Scope {
...
}

@Scope(Singleton.class)
@Service
public class SingletonService implements RandomContract {
...
}
+--------------+

    For the curious reader, you can experiment defining a new Scope implementation and have that scope used on your
@Service implementations. You will see that the HK2 runtime use the Scope instance to store/retrieve services instances
tied to that scope.

** Instantiation

    Instantiation of components

    In the IoC world, components are not instantiated using a new () method call. Components are retrieved using the
ComponentManager instance. The simplest way is to do that is through a getComponent(Class<T> contract) call although there are more
APIs available at {{{auto-depends/apidocs/org/jvnet/hk2/compinent/ComponentManager.html}ComponentManager}}

+-----------+
    /**
     * Obtains a reference to the component inside the manager.
     *
     * <p>
     * This is the "new Foo()" equivalent in the IoC world.
     *
     * <p>
     * Depending on the {@link Scope} of the component, a new instance
     * might be created, or an existing instance might be returned.
     *
     * @return
     *      non-null.
     * @throws ComponentException
     *      If failed to obtain a requested instance.
     *      In practice, failure only happens when we try to create a
     *      new instance of the component.
     */
    public <T> T getComponent(Class<T> clazz) throws ComponentException
+--------------+

** Lifecycle

    Components can attach behaviours to their construction and destruction events by implementing the {{{auto-depends/apidocs/org/jvnet/hk2/component/PostContruct.html}PostConstruct}} and/or
the {{{auto-depends/apidocs/org/jvnet/hk2/component/PreDestroy.html}PreDestroy}} interfaces. Interfaces have been used rather than annotations for performance as it is faster to cast component instance to any of these interfaces to check if the component has implemented one of them rather than using
reflection on all methods to find if they are annotated.


Inversion of Control

* Injection

    Services usually rely of other services to perform their tasks and the model described above can easily be extended
to have the HK2 runtime identify the @Contract implementations required by a service. This call for a new annotation
{{{auto-depends/apidocs/org/jvnet/hk2/annotations/Inject.html}Inject}} which can be placed on fields or setter methods of
any Service instantiated by the HK2 runtime and have that Service retrieved and injected during the service's instantiation
by the component manager.

+----------+
Field :
@Inject
ConfigService config;

Setter method :
@Inject
public void set(ConfigService svc) {..}
+----------+

    Injection can further qualify the intended injected service implementation by using a name and scope from which the
    service should be available.

+----------+
@Inject(Scope=Singleton.class, name="deploy")
AdminCommand deployCommand;
+----------+


* Extraction

    Although all Services are automatically placed into the Scope for later retrieval, it is conceivable that a component
want to extract more than itself. One pratical way of doing so is to use a Factory service, however, for simplicity, the HK2
runtime will also extract all fields or getter methods annotated with {{{auto-depends/apidocs/org/jvnet/hk2/annotations/Extract.html}Extract}}

+----------+
Field :
@Extract
ConfigService config;

Getter method :
@Extract
public ConfigService getConfigService() {..}
+----------+

    Extraction can also use the name and scope annotation fields to further qualify the extracted Contract implementation.

* Instantiation cascading

    Injection of instances which have not been already instantiated triggers more instantiation. In a sense, you can see this
as a components instantiation cascading where some code requests for a high level Service will in turn throuh @Inject
annotation requires more injection/instantiation of lower level Services. This important feature is a great tool to keep
the implementation as private as possible while relying on interfaces and separation of contract/providers.

    Below is the example of how the instantiation of DeploymentService as a Startup contract implementation will trigger
    the instantiation of the ConfigService.
    
+----------+
@Contract
public interface Startup {...}

Iterable<Startup> startups;
startups = componentMgr.getComponents(Startup.class);

@Service
public class DeploymentService implements Startup {

    @Inject
    ConfigService config;
}

@Service
public Class ConfigService implements ... {...}

+----------+

