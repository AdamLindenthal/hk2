
    DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.

    Copyright (c) 2010-2011 Oracle and/or its affiliates. All rights reserved.

    The contents of this file are subject to the terms of either the GNU
    General Public License Version 2 only ("GPL") or the Common Development
    and Distribution License("CDDL") (collectively, the "License").  You
    may not use this file except in compliance with the License.  You can
    obtain a copy of the License at
    https://glassfish.dev.java.net/public/CDDL+GPL_1_1.html
    or packager/legal/LICENSE.txt.  See the License for the specific
    language governing permissions and limitations under the License.

    When distributing the software, include this License Header Notice in each
    file and include the License file at packager/legal/LICENSE.txt.

    GPL Classpath Exception:
    Oracle designates this particular file as subject to the "Classpath"
    exception as provided by Oracle in the GPL Version 2 section of the License
    file that accompanied this code.

    Modifications:
    If applicable, add the following below the License Header, with the fields
    enclosed by brackets [] replaced by your own identifying information:
    "Portions Copyright [year] [name of copyright owner]"

    Contributor(s):
    If you wish your version of this file to be governed by only the CDDL or
    only the GPL Version 2, indicate your decision by adding "[Contributor]
    elects to include this software in this distribution under the [CDDL or GPL
    Version 2] license."  If you don't indicate a single choice of license, a
    recipient has the option to distribute your version of this file under
    either the CDDL, the GPL Version 2 or to extend the choice of license to
    its licensees as provided above.  However, if you add GPL Version 2 code
    and therefore, elected the GPL Version 2 license, then the option applies
    only if the new code is made subject to such option by the copyright
    holder.

                                                                                                                ------
                                                                                                                Run Level Services
                                                                                                                ------
                                                                                                                Jeff Trent
                                                                                                                ------
                                                                                                                ---

Introduction

    The HK2 component system uses {{{./hk2-api/apidocs/org/jvnet/hk2/annotations/RunLevel}RunLevel}} to form higher levels of component lifecycle. HK2 normally employs a “lazy instantiation” model for component creation. However, there are situations where the developer may want the instantiation to occur either immediately upon HK2 initialization or otherwise on some more regimented schedule.

* RunLevel's

    The {{{./hk2-api/apidocs/org/jvnet/hk2/annotations/RunLevel}RunLevel}} is a declarative form of annotation that you place on your Service class as shown in this example.

+--------------+
@RunLevel(1)
@Service
public MyService implements MyContract {
...
}
+--------------+

    In this example, MyService was declared to be in run level "1" in the default, or global, run level scoping.  This is called the run level value (in OSGi this is similar to the start level). The run level value must be an integer value. Run Level Scoping will be explained later.

* RunLevelService

    The {{{./auto-depends/apidocs/org/jvnet/hk2/component/RunLevelService}RunLevelService}} is the controller responsible for (automatically) instantiating services annotated with the RunLevel annotation using the proceedTo() method on the RunLevelService interface.

+--------------+
...
@Inject
RunLevelService rls;

public void start() {
  rls.proceedTo(1);
}
...
+--------------+


    It is also possible to interrogate the current and planned run levels (if the RunLevelService is currently operating) using the getState() method of the interface.


* Runtime Start Order

    When two services are found to be in the same RunLevel they will be instatiated during the RunLevelService's proceedTo() operation provided that the run level value on the service is less than or equal to the argument passed to proceedTo(). The RunLevel service operates one run level value at a time.

+--------------+
@RunLevel(1)
@Service
public MyService1 implements MyContract {
}

@RunLevel(1)
@Service
public MyService2 implements MyContract {
}

@RunLevel(2)
@Service
public MyService3 implements MyContract {
}

@RunLevel(2)
@Service
public MyService4 implements MyContract {
  @Inject
  MyService3 myService3;
}
+--------------+

    In this example, assuming we start from run level vlaue 0, a call to rls.proceedTo(2) will first instantiate (MyService1 | MyService2). While both services
will eventually be instantiated, it is non-deterministic which of the two will actually come first.

    After all services annotated with the value of 1 in the default/global run level scope is located and instantiated from the HK2 service registry the system will
proceed to run level value 2. This case is different in that the start order is deterministic - at least with respect to MyService3 and MyService4.  MyService3 must
be started before MyService4 because MyService4 depends upon (i.e., injects) MyService3.


* Runtime Stop Order

    The {{{./auto-depends/apidocs/org/jvnet/hk2/component/RunLevelService}RunLevelService}} can also be used to shutdown / release services that were previously
instantiated. Continuing from the previous example, a call to proceedTo(0) will release MyService1 - MyService4. Note that shutdown will occur in the reverse order
from the instantiation order.  So the shutdown order will therefore be MyService4, MyService3, (MyService1 | MyService2).


* The "Kernel" RunLevel

    The kernel run level has the value -1. It is considered special in that Services annotated with it will be instantiated immediately upon HK2 startup.


* Meta Annotations

    As a convenience, you can create a meta annotation (i.e., stereotype) to use a more meaningful name/type to describe your RunLevel. HK2 comes with one
such meta-annotation called @Immediate having run level value -1 as described above.

+--------------+
@Retention(RUNTIME)
@Target(TYPE)
@Inherited
@RunLevel(RunLevel.KERNEL_RUNLEVEL)
public @interface Immediate {}
+--------------+

* RunLevel Scope

    The RunLevel Scope, not to be confused with component {{{./hk2-api/apidocs/org/glassfish/hk2/Scope.html}Scope}}, permits namespace groupings of services to
occur. When not declared on the RunLevel annotation, the default, or global, run level scope is implied. A class type is used to represent the run level scope and
will default to {{{./hk2-api/apidocs/org/glassfish/hk2/RunLevelDefaultScope.html}RunLevelDefaultScope}} unless otherwise specified.

    RunLevel scoping is useful for modeling lifecycle for sub-systems which span more than a single service (e.g., "the ejb container",
"the logging sub system", etc.).

    See {{Extensions}} for more information


The Default RunLevelService

    HK2 comes configured with a default RunLevelService responsible for the services that are using the default, or global, RunLevel scope. The default RunLevel Service 
delegates part of its work to other services it attempts to find from the HK2 service registry. These services include the
{{{./auto-depends/apidocs/org/jvnet/hk2/component/InhabitantSorter}InhabitantSorter}} and the 
{{{./auto-depends/apidocs/org/jvnet/hk2/component/InhabitantActivator}InhabitantActivator}}.


* The Inhabitant Sorter

    Earlier it was suggested that the start order of services in the same run level is non-deterministics. That was partially true. When no InhabitantActivator is found
in the HK2 service registry the start order can be assumed to be non-deterministic. However, callers can declare a service implementing this contract and the default
RunLevelService will delegate to it when sorting the services before instantiation occurs.


* The Inhabitant Activator

    The InhabitantActivator service is another service that can be optionally declared in order to have the default RunlevelService delegate the actually instantiation/
activation during startup and also the release/deactivation during shutdown.


Extensions

    As shown previously, run level scoping can be used useful for modeling lifecycle of sub-systems. Here is an example of how run level scope can be declared on a service.

+--------------+
@RunLevel(2, runLevelScope=MySubsystemScope.class)
@Service
public MySubsystemService implements MyContract {
}
+--------------+

    Here, MySubsystemService is now mapped to the MySubsystemScope run level scope.  Note that it's perfectly fine to also declare meta-annotations for scoped
run levels as well.

    It is important that if you are using run level scoping extensions, you will also be responsible for implementing a
{{{./auto-depends/apidocs/org/jvnet/hk2/component/RunLevelService}RunLevelService}} associated with your scope.  Fortunately, HK2 provides an easy way to do this by
extending the {{{./auto-depends/apidocs/org/jvnet/hk2/component/AbstractRunLevelService}AbstractRunLevelService}}.

+--------------+
@Service(metadata=RunLevel.META_SCOPE_TAG + "=...package-to...MySubsystemScope")
public class MySubsystemRunLevelService extends AbstractRunLevelService<MySubsystemScope> {
    public MySubsystemRunLevelService() {
        super(MySubsystemScope.class);
    }
}
+--------------+


Constraint Rules

    RunLevel annotated services are different from normal services because they are governed by different lifecycle rules. Imagine a situation where a non-RunLevel annotated service declares an injection point of a RunLevel annotated service.

+--------------+
@Service
public StandardService {
  @Inject
  MyService4 myService4;
}

@RunLevel(2)
@Service
public MyService4 implements MyContract {
}
+--------------+

    If someone attempt to obtain (or be injected with) a StandardService, it is ambiguous whether or not the operation can be successful since it depends on the state of the default run level service. If the current run level is 0 then the StandardService cannot be instantiated because it needs a MyService4 instance that is not permitted to be
created until run level value 2 is reached.  Furthermore, assume that the run level is current at 3, and it HK2 permitted the acquisition of StandardService injected with
an instance of MyService4. Now, if shutdown occurs (i.e., proceedTo(0)) then the StandardService#myService4 instance becomes an orphan from the Habitat.

    These issues are avoided by certain semantic rules put in force when using RunLevel annotated services.  These rules include:

    * A standard, non-RunLevel annotated service can not be injected with a RunLevel annotated service.

    * A RunLevel annotated service with run level value N can not be injected with a RunLevel annotated service with value M when M > N.

    * A RunLevel annotated service in run level scope X cannot be injected with a a RunLevel annotated service in run level scope Y when X != Y.

    []

    <<All rules are enforced at runtime.>>

    There is one exception that is provided to these constraint rules. Holder-style injection bypasses the normal constraint rules above.


    The Holder will act as a proxy to the service and be set to null when the service has not been activated, and a non-null value when it has been instantiated.

+--------------+
@Service
public StandardService {
  @Inject
  Holder<MyService4> myService4Holder;
}

@RunLevel(2)
@Service
public MyService4 implements MyContract {
}
+--------------+

    It is important to note, however, that the service instance obtained from the Holder should never be cached or otherwise held unto for extended periods of time
(i.e., not carried in a class field) since the run level annotated service can eventually be nulled when the run level service responsible for that service is shutting down.  Also be careful to perform null checks at all times.

