Introduction

    The RunLevelService was designed to offer life cycle controller mechanisms to a system. Life cycle involves the starting or stopping of a system in phases, known as run levels.

    This is a departure from the traditional, ternary style of system life cycle which was represented by the state machine (NotStarted_or_Shutdown <--> Starting_or_Stopping <--> Running). The issue with the traditional approach is that it doesn't offer the proper granularity to target more nuanced features. For example, consider an application server that wants to startup to a level where it can managed by a systems administrator but before it is made available for general public use. By adding an "admin run level" the state machine for the application server now becomes (NotStarted_or_Shutdown <--> Starting_or_Stopping <--> <<Admin>> <--> Running).

    The RunLevelService was also designed to support sub-systems within the global system, where the same life cycle controllers can be used, but having a different set of run levels that are meaningful to that sub-system.


Overview

    The HK2 component system uses {{{./hk2-api/apidocs/org/jvnet/hk2/annotations/RunLevel.html}RunLevel}} to form higher levels of component life cycle. HK2 normally employs a “lazy instantiation” model for component creation.  However, there are situations where the developer may want the instantiation to occur either immediately upon HK2 initialization or otherwise on some more regimented schedule. This can be accomplished using the RunLevel annotation.

* RunLevel's

    The {{{./hk2-api/apidocs/org/jvnet/hk2/annotations/RunLevel.html}RunLevel}} is a declarative form of annotation that you place on your Service class as shown in this example.

+--------------+
@RunLevel(1)
@Service
public MyService implements MyContract {
...
}
+--------------+

    In this example, MyService was declared to be in run level "1" in the default, or global, run level scoping.  This is called the run level value (in OSGi this is similar to the start level). The run level value must be an integer value. Run Level Scoping will be explained later.

* RunLevelService

    The {{{./auto-depends/apidocs/org/jvnet/hk2/component/RunLevelService.html}RunLevelService}} is the controller responsible for (automatically) instantiating services annotated with the RunLevel annotation using the proceedTo() method on the RunLevelService interface.

+--------------+
...
@Inject
RunLevelService rls;

public void start() {
  rls.proceedTo(1);
}
...
+--------------+


    It is also possible to interrogate the current and planned run levels (if the RunLevelService is currently operating) using the getState() method of the interface.


* Runtime Start Order

    When two services are found to be in the same RunLevel they will be instatiated during the RunLevelService's proceedTo() operation provided that the run level value on the service is less than or equal to the argument passed to proceedTo(). The RunLevel service operates one run level value at a time.

+--------------+
@RunLevel(1)
@Service
public MyService1 implements MyContract {
}

@RunLevel(1)
@Service
public MyService2 implements MyContract {
}

@RunLevel(2)
@Service
public MyService3 implements MyContract {
}

@RunLevel(2)
@Service
public MyService4 implements MyContract {
  @Inject
  MyService3 myService3;
}
+--------------+

    In this example, assuming we start from run level vlaue 0, a call to rls.proceedTo(2) will first instantiate (MyService1 | MyService2). While both services
will eventually be instantiated, it is non-deterministic which of the two will actually come first (more on this later).

    After all services annotated with the value of 1 in the default/global run level scope is located and instantiated from the HK2 service registry the system will
proceed to run level value 2. This case is different in that the start order is deterministic - at least with respect to MyService3 and MyService4.  MyService3 must
be started before MyService4 because MyService4 depends upon (i.e., injects) MyService3.


* Runtime Stop Order

    The {{{./auto-depends/apidocs/org/jvnet/hk2/component/RunLevelService.html}RunLevelService}} can also be used to shutdown / release services that were previously
instantiated. Continuing from the previous example, a call to proceedTo(0) will release MyService1 - MyService4. Note that shutdown will occur in the reverse order
from the instantiation order.  So the shutdown order will therefore be MyService4, MyService3, (MyService1 | MyService2).


* The "Kernel" RunLevel

    The kernel run level has the value -1. It is considered special in that Services annotated with it will be instantiated immediately upon HK2 startup.


* Meta Annotations

    As a convenience, you can create a meta annotation (i.e., stereotype) to use a more meaningful name/type to describe your RunLevel. HK2 comes with one
such meta-annotation called @Immediate having run level value -1 as described above.

+--------------+
@Retention(RUNTIME)
@Target(TYPE)
@Inherited
@RunLevel(RunLevel.KERNEL_RUNLEVEL)
public @interface Immediate {}
+--------------+

* RunLevel Scope

    The RunLevel Scope, not to be confused with component {{{./hk2-api/apidocs/org/glassfish/hk2/Scope.html}Scope}}, permits namespace groupings of services to
occur. When not declared on the RunLevel annotation, the default, or global, run level scope is implied. A class type is used to represent the run level scope and
will default to {{{./hk2-api/apidocs/org/glassfish/hk2/RunLevelDefaultScope.html}RunLevelDefaultScope}} unless otherwise specified.

    RunLevel scoping is useful for modeling life cycle for sub-systems which span more than a single service (e.g., "the ejb container",
"the logging sub system", etc.).

    See {{Extensions}} for more information


The Default RunLevelService

    HK2 comes configured with a default RunLevelService responsible for the services that are using the default, or global, RunLevel scope. The default RunLevel Service 
delegates part of its work to other services it attempts to find from the HK2 service registry. These services include the
{{{./auto-depends/apidocs/org/jvnet/hk2/component/InhabitantSorter.html}InhabitantSorter}} and the 
{{{./auto-depends/apidocs/org/jvnet/hk2/component/InhabitantActivator.html}InhabitantActivator}}.

    In addition to delegating work to the sorter and activator, the default RunLevelService sends certain events to it's RunLevelListener(s).


* The Inhabitant Sorter and Priority

    Earlier it was suggested that the start order of services in the same run level is non-deterministics. This is a partially true statement because the services were unrelated to one another. The "real" answer is as follows. The start order can be established within a given run level when either there is (a) an InhabitantActivator applied, or (b) the default inhabitant activator is used in conjunction with {{{./hk2-api/apidocs/org/jvnet/hk2/annotations/Priority.html}Priority}} annotation being applied to the service. Otherwise the start order can be assumed to be non-deterministic.

    Callers can declare a service implementing the InhabitantActivator or apply the Priority annotations to affect the behavior of the default RunLevelService.


* The Inhabitant Activator

    The InhabitantActivator service is another service that can be optionally declared in order to have the default RunlevelService delegate the actually instantiation/
activation during startup and also the release/deactivation during shutdown.


* The RunLevelListener

    The set of {{{./auto-depends/apidocs/org/jvnet/hk2/component/RunLevelListener.html}RunLevelListener}}s associated with the default RunLevelService will be notified of
important events during it's operations. It is important to note that the default RunLevelService captures most Throwable types and sends them to the listeners - in
general Exceptions are not emitted out to the caller of the default RunLevelService.  The listeners are also notified of progress and cancellation events.


** Interruption

    In the event the listener encounters a critical error and it is desirable for the operations of the default RunLevelService to be aborted, then an interrupt() could
be called on the RunLevelService instance. The implementation is thread safe so that interrupt() can be called from the listener or by some other monitoring thread.

** AsyncPostConstruct

    In some situations, a component / service acts in such a way that it spawns threads to complete other internal initialization operations.  In such situations it is recommended that the service implements {{{./hk2-api/apidocs/org/glassfish/hk2/AsyncPostConstruct.html}AsyncPostConstruct}} instead of the standard PostConstruct contract.  The default RunLevelService will wait for all asynchronous operations to complete at a given run level before attempting to continue the startup process proceeding to subsequent run levels.


Extensions

    As shown previously, run level scoping can be used useful for modeling life cycle of sub-systems. Here is an example of how run level scope can be declared on a service.

+--------------+
@RunLevel(2, runLevelScope=MySubsystemScope.class)
@Service
public MySubsystemService implements MyContract {
}
+--------------+

    Here, MySubsystemService is now mapped to the MySubsystemScope run level scope.  Note that it's perfectly fine to also declare meta-annotations for scoped
run levels as well.

    It is important to note that if you are using run level scoping extensions, you will also be responsible for implementing a
{{{./auto-depends/apidocs/org/jvnet/hk2/component/RunLevelService.html}RunLevelService}} associated with your scope.  Fortunately, HK2 provides an easy way to do this by
extending the {{{./auto-depends/apidocs/org/jvnet/hk2/component/AbstractRunLevelService.html}AbstractRunLevelService}}.

+--------------+
@Service(metadata=RunLevel.META_SCOPE_TAG + "=...package-to...MySubsystemScope")
public class MySubsystemRunLevelService extends AbstractRunLevelService<MySubsystemScope> {
    public MySubsystemRunLevelService() {
        super(MySubsystemScope.class);
    }
}
+--------------+

    The RunLevel.META_SCOPE_TAG set in the metadata of the system is the important point to remember. The same approach for setting the metadata having RunLevel.META_SCOPE_TAG should also be used when creating custom activators, sorters, and listeners. Any instance
of these types that are not annotated in this way will be assumed to belong to the default RunLevelService. The AbstractRunLevelService provides setters to override
some of this default functionality - see the javadoc for details.


Constraint Rules

    RunLevel annotated services are different from normal services because they are governed by different life cycle rules. Imagine a situation where a non-RunLevel annotated service declares an injection point of a RunLevel annotated service.

+--------------+
@Service
public StandardService {
  @Inject
  MyService4 myService4;
}

@RunLevel(2)
@Service
public MyService4 implements MyContract {
}
+--------------+

    If someone attempt to obtain (or be injected with) a StandardService, it is ambiguous whether or not the operation can be successful since it depends on the state of the default run level service. If the current run level is 0 then the StandardService cannot be instantiated because it needs a MyService4 instance that is not permitted to be
created until run level value 2 is reached.  Furthermore, assume that the run level is current at 3, and HK2 permitted the acquisition of StandardService injected with
an instance of MyService4. Now, if partial shutdown occurs (i.e., proceedTo(1)) then the StandardService#myService4 instance becomes an orphan from the Habitat and may cause an error.

    These issues are avoided by three semantical constraints placed on the use of RunLevel annotated services.  These rules include:

    * A standard, non-RunLevel annotated service can not be injected with a RunLevel annotated service.

    * A RunLevel annotated service with run level value N can not be injected with a RunLevel annotated service with value M when M > N.

    * A RunLevel annotated service in run level scope X cannot be injected with a RunLevel annotated service in run level scope Y when X != Y.

    []

    <<All rules are enforced at runtime.>>

    There are two exceptions that are provided to bypass these constraint rules:

    * Holder-style injection bypasses the normal constraint rules.

    The Holder will act as a proxy to the service and be set to null when the service has not been activated, and a non-null value when it has been instantiated.

+--------------+
@Service
public StandardService {
  @Inject
  Holder<MyService4> myService4Holder;
}

@RunLevel(2)
@Service
public MyService4 implements MyContract {
}
+--------------+

    It is important to note, however, that the service instance obtained from the Holder should never be cached or otherwise held unto for extended periods of time
(i.e., not carried in a class field) since the run level annotated service can eventually be nulled when the run level service responsible for that service is shutting down. Also be careful to perform null checks at all times.

    * RunLevel(strict=false)

    Declaring the run level with strict=false simply provides a means to create demand for the service when reaching the given run level. It will NOT, however, be managed / released as part of shutdown processing.

    See the javadoc for additional details.

    []

