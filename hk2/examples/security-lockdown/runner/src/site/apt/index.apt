Security Lockdown Example

 In this example we will show how to check every injection, lookup, bind
 and unbind operation against a set of J2SE security permissions.  In order
 to do so we have constructed four projects who have a different set of
 permissions in the system.  Lets take a brief glimpse of each project
 in the example, to get an overview of what they do and how they interact
 with the system.  
 
 The first project is the runner project, which is nothing more than a set of
 junit tests which run various scenarios, showing how security is either granted
 or denied to the other projects.
 
 The next project is the system project, which is considered to be secure and
 trusted system code.  This code will receive AllPermission and therefor is able
 to manipulate any object in the system and perform any action.  The system code
 contains things like the security validation service itself, along with other
 secure code such as security services.
 
 Another project is called "Alice."  Alice is an application provider that is
 able to access security services.  Alice will not attempt to do anything bad, but
 will remain within the confines of the permissions granted her.  However, Alice
 does not have AllPermission, and therefore could not perform some operations even
 if she tried (however, she never tries to do anything she shouldn't).
 
 Mallory is the last project.  Mallory is another application provider, who also
 has some access to system resources.  In fact, Mallory has access to the Alice application.
 Mallory usually sticks to the bounds of what he is allowed to do, but sometimes will attempt
 to perform operations that he is not allowed to perform.  We shall see that when he attempts
 to do so he is rebuffed by the security operations of the system.
 
 Lets take a look in detail at how this total security lockdown of the system occurs.
 
The System Project

 The system project has some resources it would like to give out to some applications,
 but not to others.  It would also like to be able to prevent applications from
 binding or unbinding services from the service registry (embodied by the
 {{{./apidocs/org/glassfish/hk2/api/ServiceLocator.html}ServiceLocator}}).
 
 In order to do this, the system project must decide on a protection scheme.  Therefore the
 decision is made that only code with java.lang.AllPermission shall be able to bind or unbind
 services.  In order to protect lookup and injection services the decision is made to use
 the java.lang.RuntimePermission called "accessClassInPackage".  This permission is used to allow
 code to access classes in a particular package, and so seems appropriate for also protecting services
 that are from that particular package.
 
 It should be noted that the above decisions were made arbitrarily for this example, and real system
 code can use whatever permission scheme it desires, including creating and using its own Permission
 classes.
 
 Lets first take a look at the resource that the system project would like to protect.  You will see
 in the package "org.acme.security" that there is a service called AuditService.  AuditService is an
 extremely simple secure auditing service.  The system code would like to allow some applications access
 to this service, and other applications to NOT be allowed to directly use this service.  It should be noted
 that the code that CAN access the service may be able to use that service on behalf of the callers of that
 service.  That sort of thing will all work according to the normal J2SE security model.  Here is the AuditService,
 a service that should be protected:
 
+---
@Service @Singleton
public class AuditService {
    ...
}
+---

 The most important thing to notice about this service is that there is nothing at all special about it.  It is
 not annotated with any sort of special annotation or indication that it is a secure or protected service.  This
 is because in some environments this service may be protected, while in other environments it may not be protected.
 It is up to the environment to decide which resources need to be protected, and which do not.  In this way the
 burden of deciding which resources are to be protected and which are not are taken away from the developers of the
 resource and put into the hands of the definition of the particular environment in which those resources run.  This
 is a good thing, as it puts the burden of deciding which resources are to be protected into the hands of those who
 can better make that decision.
 
 But how *does* the environment decide which resources are protected, and which are not?  In HK2 the answer is a
 system defined service called the {{{./apidocs/org/glassfish/hk2/api/ValidationService.html}ValidationService}}.
 The {{{./apidocs/org/glassfish/hk2/api/ValidationService.html}ValidationService}} has two functions.  The first
 function is to decide which resources should be protected.  The second is to provide code that must be run in
 order to protect the resources which are protected.
 
 In this example, the system has decided that every resource must be protected.  Hence the name "security-lockdown"
 example.  Every injection point, lookup and bind will first run through a
 {{{./apidocs/org/glassfish/hk2/api/Validator.html}Validator}} to decide whether or not that operation should be allowed
 to proceed.  But before the {{{./apidocs/org/glassfish/hk2/api/Validator.html}Validator}} is run on anything first the
 {{{./apidocs/org/glassfish/hk2/api/ValidationService.html}ValidationService}} must tell the system that all resources
 are to be protected.
 
 In order to do this the system project must implement the
 {{{./apidocs/org/glassfish/hk2/api/ValidationService.html}ValidationService}}.  In doing so it must implement
 the getLookupFilter API, which returns a {{{./apidocs/org/glassfish/hk2/api/Filter.html}Filter}} to
 the system.  The system will use this filter to determine which resources are protected.  If the filter returns
 true about any resource, then that resource will have the {{{./apidocs/org/glassfish/hk2/api/Validator.html}Validator}}
 run over it whenever it is looked up or injected.  Note that bind and unbind operations are always run through
 all registered validators, as these operations are rare and can have serious effects on the state of the system.
 
 In our example, where we want to protect every resource, we implement the getLookupFilter in this way:
 
+---
@Service @Singleton
public class ValidationServiceImpl implements ValidationService {
    ...
    
    @Override
    public Filter getLookupFilter() {
        return BuilderHelper.allFilter();
    }
    
    ...
}
+---

 The {{{./apidocs/org/glassfish/hk2/utilities/BuilderHelper.html}BuilderHelper}} allFilter method returns a
 {{{./apidocs/org/glassfish/hk2/api/Filter.html}Filter}} that always returns true.  In this way we have assured
 that every lookup and injection in the system will be run through the implementation of
 {{{./apidocs/org/glassfish/hk2/api/Validator.html}Validator}}, which is also returned by out implementation of
 the {{{./apidocs/org/glassfish/hk2/api/ValidationService.html}ValidationService}}:
 
+---
@Service @Singleton
public class ValidationServiceImpl implements ValidationService {
    private final ValidatorImpl validator = new ValidatorImpl();
    
    ...

    @Override
    public Validator getValidator() {
        return validator;
    }
}
+---

 Note that since the ValidationService is a Singleton service that the ValidatorImpl will only be created once,
 and the same one will be returned to the system every time the getValidator method is called.
 
 However, the most important thing about the system code is how it protects the resources it has been charged
 to protect.  That is the job of the ValidatorImpl.  The ValidatorImpl is responsible for determining
 how to validate the BIND, UNBIND and LOOKUP operations.  Here is the implementation of the
 {{{./apidocs/org/glassfish/hk2/api/Validator.html}Validator}} validate method:
 
+---
public class ValidatorImpl implements Validator {
    ...
    
    @Override
    public boolean validate(Operation operation, ActiveDescriptor<?> candidate,
            Injectee injectee) {
        switch(operation) {
        case BIND:
        case UNBIND:
            return validateBindAndUnbind();
        case LOOKUP:
            return validateLookup(candidate, injectee);
        default:
            return false;
        }
    }
    
    ...
    
}
+---

 It is very important to understand the context in which these calls are made.  In that way it can be determined
 how to check the permission being granted.  In the BIND, UNBIND and LOOKUP case that is *not* an injection (more
 on that later) the java call frame will contain the operation being performed.  In the case of the
 BIND and UNBIND operations this will include the code that called commit on the
 {{{./apidocs/org/glassfish/hk2/api/DynamicConfiguration.html}DynamicConfiguration}}.  In the case of the
 non-inject lookup, this will contain the user that ultimately attempted to look up a service.
 
 Since the BIND and UNBIND cases are fairly strait-forward in our example, lets see how this permission
 check is performed.  First, we make a checkPermission call that returns true or false depending on whether
 or not the permission is granted or not.  Here it is:
 
+---

    private static boolean checkPerm(Permission p) {
        try {
            AccessController.checkPermission(p);
            return true;
        }
        catch (AccessControlException ace) {
            return false;
        }
    }
+---

 This converts any AccessControlException (an indication that the permission was NOT granted) into a simple
 false value.  Otherwise, if the checkPermission call is successful this method will return true.  It should
 be noted that using the checkPermission in this way will only work properly when the code to be checked is
 on the call stack, and that every piece of code on the call-stack must have the permission being asked for.
 For the BIND and UNBIND operations then, the check is easy, since the caller is on the stack and this method
 is easy to use:

+---
    private boolean validateBindAndUnbind() {
        return checkPerm(new AllPermission());
    }
+---

 This is very simple and ensures that anyone who tries to BIND or UNBIND service descriptions into the system
 must have AllPermission!
 
 Now lets talk about the lookup case.  The lookup case can be broken down into two cases, the true lookup case
 and the injection case.  Both are doing a lookup of a service.  However in the first case (pure lookup) the
 caller is directly on the stack.  In the second case there may be no other software on the stack than the
 system software.  Therefore in that case more information may be needed in order to perform our security check.
 That extra information comes in the form of the
 {{{./apidocs/org/glassfish/hk2/api/Injectee.html}Injectee}}.  Using the combination of the candidate
 {{{./apidocs/org/glassfish/hk2/api/ActiveDescriptor.html}ActiveDescriptor}} and the
 place that descriptor would be injecting into (the
 {{{./apidocs/org/glassfish/hk2/api/Injectee.html}Injectee}}) a security decision can be made about the
 injection point.
 
 Lets look at the method that handles the lookup case:
 
+---
    private boolean validateLookup(ActiveDescriptor<?> candidate, Injectee injectee) {
        if (injectee == null) {
            return validateLookupAPI(candidate);
        }
        
        return validateInjection(candidate, injectee);
    }
+---

 As you can see from the above code, the lookup has been broken into two cases, the
 lookup with the API case, and the lookup based on the injection point case.  The
 lookup with the API case is similar to the BIND and UNBIND cases, since the permission
 check simply goes against the current call stack.  However, before we look at how
 validateLookupAPI is implemented,  lets look at how we create the set of permissions
 that are necessary for the caller to be allowed to use the lookup API.
 
 Firstly, we create a RuntimePermission for a particular package by calling this
 method:
 
+---
    private final static String ACCESS_IN_PACKAGE = "accessClassInPackage.";
    
    private static Permission getLookupPermission(String packName) {
        RuntimePermission retVal = new RuntimePermission(ACCESS_IN_PACKAGE + packName);
        
        return retVal;
    }
+---

 The above code will create the Permission that needs to be checked to see if the
 caller should have access to the passed in package.
 
 When dealing with an {{{./apidocs/org/glassfish/hk2/api/ActiveDescriptor.html}ActiveDescriptor}},
 we want to be sure that the caller has the right to access all of the contracts which
 that service advertises.  Hence we create a method that returns all of the permissions
 that must be checked based on all of the contracts that the
 {{{./apidocs/org/glassfish/hk2/api/ActiveDescriptor.html}ActiveDescriptor}} advertises.
 Here is the implementation of that method:
 
+---
    private static List<Permission> getLookupPermissions(ActiveDescriptor<?> ad) {
        LinkedList<Permission> retVal = new LinkedList<Permission>();
        
        for (String contract : ad.getAdvertisedContracts()) {
            int index = contract.lastIndexOf('.');
            String packName = contract.substring(0, index);
            retVal.add(getLookupPermission(packName));
        }
        
        return retVal;
    }
+---

 Forearmed with the above methods, we can now look at how the method which
 checks whether or not the lookup should be authorized.  Here is the implementation
 of validateLookupAPI:
 
+---
    private boolean validateLookupAPI(ActiveDescriptor<?> candidate) {
        List<Permission> lookupPermissions = getLookupPermissions(candidate);
     
        for (Permission lookupPermission : lookupPermissions) {
            if (!checkPerm(lookupPermission)) {
                if (VERBOSE) {
                    System.out.println("candidate " + candidate +
                        " LOOKUP FAILED the security check for permission " + lookupPermission);
                }
                return false;
            }
        }
        
        return true;
    }
+---

  This is a strait-forward implementation, simply ensuring with the checkPerm call that
  the caller is allowed to access all of the contracts offered by the given candidate.
  
  That leaves us with the case of the lookup being performed on behalf of an injection
  point.  This sort of lookup might be done because of some system code, or on the behalf
  of a chain of instantiations being done due to the dependency chain.  Hence, it may
  not be the case that the proper protection domain is on the calling stack.