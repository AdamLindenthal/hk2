    ------
    HK2 Testing with JUnit.
    ------
    Jerome Dochez
    ------
    ------

    Any hk2-jar or jar maven module importing hk2 can develop junit tests that will be injected with resources available in the hk2 habitat.

Maven project requirements.

    If your project type is hk2-jar, you have nothing to do. When using a plain maven jar module, you must add the following dependency in your pom.xml

+-----------------------+
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>4.5</version>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>com.sun.enterprise</groupId>
            <artifactId>auto-depends</artifactId>
            <version>..hk2 version ...</version>
        </dependency>
+-----------------------+

    The structure of a normal maven projects applies :

+-----------------------+
./pom.xml
./src
./src/main
./src/main/java
   [ put all your module services and contract definition as you expect them to be used ]
./src/test
./src/test/java
   [ put all your junit tests and mockup services implementation ]
+-----------------------+

Example

* Contract definition

    put your contract definition :

+-----------------------+
package org.glassfish.hk2.junit.samples.simple;

import org.jvnet.hk2.annotations.Contract;

/**
 * Simple contract definition
 */
@Contract
public interface RandomContract {

    /**
     * Adds the two paramters and return the result
     * @param i the first element to add
     * @param j the second
     * @return the addition of i and j
     */
    int add(int i, int j);
}
+-----------------------+

    in the usual location :

    ./src/main/java/org/glassfish/hk2/junit/samples/simple/tests/RandomContractTest.java

* Service implementation

+-----------------------+
package org.glassfish.hk2.junit.samples.simple.org.glassfush.hk2.junit.samples.simple.impl;

import org.glassfish.hk2.junit.samples.simple.RandomContract;
import org.jvnet.hk2.annotations.Service;

/**
 * Random contract implementation
 */
@Service
public class RandomService implements RandomContract {
    public int add(int i, int j) {
        return i+j;
    }
}
+-----------------------+

    in the usual location :

    ./src/main/java/org/glassfish/hk2/junit/samples/simple/impl/RandomService.java

* Test definition

+-----------------------+
package org.glassfish.hk2.junit.samples.simple.tests;

import org.glassfish.hk2.junit.samples.simple.RandomContract;
import org.junit.Assert;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.jvnet.hk2.annotations.Inject;
import org.jvnet.hk2.junit.Hk2Runner;

/**
 * Simple test of RandomContract
 */
@RunWith(Hk2Runner.class)
public class RandomContractTest {

    @Inject
    RandomContract myService;

    @Test
    public void twoPlusTwo() {
        int result = myService.add(2,2);
        Assert.assertTrue(result==4);
    }
}
+-----------------------+

    in the usual test location :

    ./src/test/java/org/glassfish/hk2/junit/samples/simple/tests/RandomContractTest.java

Mockup services

    Obviously, you sometimes need to develop mock up implementations of some services that will be used directly by your test or by a service of your module. Say you have the following contract definition :

+-----------------------+
/**
 * an important contract that cannot necessarily be instantiated during unit tests
 *
 */
@Contract
public interface ImportantContract {

    public String getUserNameFromSecureDB();

    public String getCompleteName();

}
+-----------------------+

    Now some other service inside your module (not necessarily a test) :

+-----------------------+
@Service
public class ServiceUser {
    @Inject
    ImportantContract imp;

    public String tellMe() {
        return "Bonjour " + imp.getCompleteName();
    }
}
+-----------------------+
    somewhere in src/main/java.

    Now you don't have an implementation of this ImportantContract contract in your modules source. But you can have a
    mock up implementation in your unit test source directory to satisfy the dependency and be able to test the system
    as a whole, like if the contract was available.

+-----------------------+
@Service
public class ImportantContractHardCoded implements ImportantContract {

    @Inject
    RandomContract sub;

    public String getUserNameFromSecureDB() {
        return "Dochez";
    }

    public String getCompleteName() {
        return sub.concatenate("Jerome", "Dochez");
    }
}
+-----------------------+

    inside src/test/java/org/glassfish/hk2/junit/samples/simple/tests/mockup/ImportantContractHardCoded.java

    and now your test is simple enough :

+-----------------------+
@RunWith(Hk2Runner.class)
public class ServiceUserTest {

    @Inject
    ServiceUser su;

    @Test
    public void userTest() {
        System.out.println(su.tellMe());
    }
}
+-----------------------+

    Since your mockup implementation is part of src/test/java, it will not be shipped with your module binary and pollute the product habitat.

    Manually adding services to the Servics.
    Sometimes, it is necessary to manually add services to the habitat (or swap existing ones with mockup versions)
    Look at the @BeforeClass annotated method that register a few extra services to satisfy dependency.

+-----------------------+
@RunWith(Hk2Runner.class)
public class CommandRunnerTest {

    @Inject
    CommandRunner commandRunner;

    @BeforeClass
    public static void setup() {
        Services services = Hk2Runner.getServices();

        DynamicBinderFactory binder = services.bindDynamically();
        binder.bind().to(new StartupContext());
        binder.bind(ModulesRegistry.class).to(new SingleModulesRegistry(CommandRunnerTest.class.getClassLoader());
        binder.commit();
    }


    @Test
    public void tryOut() {
        Assert.assertTrue(commandRunner!=null);
        try {
            ActionReport report = commandRunner.getActionReport("plain");
            CommandRunner.CommandInvocation inv = commandRunner.getCommandInvocation("list-contracts", report);
            inv.execute();
            System.out.println(report.getTopMessagePart().getMessage());
            for (ActionReport.MessagePart child : report.getTopMessagePart().getChildren()) {
                System.out.println(child.getMessage());
            }
        } catch(Exception e) {
            e.printStackTrace();
        }
    }
}
+-----------------------+

* How does it work ?

    I use a special JUnit runner to run the test and inject them. Not all the junit features are available with the new Runner, if you run into issues, please ping me.
    Also the tests compilation does not generate the META-INF/inhabitant/default file, I use an new introspection facility to populate the habitat from the .class files directly.
    The test execution class path is used to build the habitat, each class path element must be either a jar or a directory. If that element contains a META-INF/inhabitant file, it is used otherwise the system will introspect the jar or directory. If the jar is an OSGi bundle and the hk2 packages are not imported, the module will not be introspected for HK2 services.

