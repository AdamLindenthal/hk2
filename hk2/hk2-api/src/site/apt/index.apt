            ------
            Introduction to HK2
            ------


Compatibility

 This page describes the HK2 2.0 API, which is based on
 JSR-330 standard annotations.  Also, Habitat has been replaced with a new
 interface called {{{./apidocs/org/glassfish/hk2/api/ServiceLocator.html}ServiceLocator}}.
  
Table of Contents

 * {{Introduction}}
 
 * {{Getting Started}}
 
   * {{Named Services}}
   
   * {{Qualified Services}}
 
 * {{Basic Injection}}
    
{Introduction}

 HK2 is a declarative framework for services using annotations like
 {{{./apidocs/org/glassfish/hk2/annotations/Contract.html}Contract}} and
 {{{./apidocs/org/glassfish/hk2/annotations/Service.html}Service}}.  This page
 is intended to show simple usages of HK2 mainly using the standard JSR-330
 API.

 For information about using the HK2 progrommatic API see {{{./api.html}this page}}.
 
 For information about HK2 extensibility options see {{{./extensibility.html}this page}}.
 
 For information about JSR-330 see {{{http://www.jcp.org/en/jsr/detail?id=330}this site}}.
 
 This page assumes that you are using the HK2 provided ability to automatically find and
 register services in an HK2 registry.  For more information on how to control what services
 are automatically bound to what registries see TBD.

{Getting Started}

 In order to mark a concrete implementation class as one that should be available as a service you annotate your class with 
 {{{./apidocs/org/jvnet/hk2/annotations/Service.html}@Service}}.
 
+--------------------------------------
@Service
public class Foo {
}
+--------------------------------------

 By default Foo will be advertised as itself and by any interfaces that are marked with
 {{{./apidocs/org/jvnet/hk2/annotations/Contract.html}@Contract}}.  Lets make Foo
 an interface that is a Contract and create an implementation of Foo:
 
+--------------------------------------
@Contract
public interface Foo {
}

@Service
public class FooImpl implements Foo {
}
+--------------------------------------

 The FooImpl class will be placed into the registry advertised under both FooImpl and Foo.
 
* {Named Services}
 
 In order to differentiate different implementations of the same interface you can
 name your services.  Here is an example of a class that implements a contract and has two implementations,
 both named differently:
 
+--------------------------------------
@Contract
public interface Book {
}

@Service @Named
public class MobyDock implements Book {
}

@Service @Named
public class ParadiseLost implements Book {
}
+--------------------------------------

 The two classes, MobyDick and ParadiseLost, will be added to the service registry with the names
 "MobyDick" and "ParadiseLost".  If you use the {{{http://docs.oracle.com/javaee/6/api/javax/inject/Named.html}Named}}
 qualifier without specifying a name then the name you get is the class name without the package.
 
* {Qualified Services}

 Services can also be qualified with annotations called Qualifiers.  Qualifiers are annotations that are themselves
 annotated with {{{http://docs.oracle.com/javaee/6/api/javax/inject/Qualifier.html}@Qualifier}}.  Here is an
 example contract with three implementations:
 
+--------------------------------------
@Contract
public interface Color {
}

@Service @Blue
public class BlueColor implements Color {
}

@Service @Red
public class RedColor implements Color {
}

@Service @Yellow
public class YellowColor implements Color {
}
+--------------------------------------

 The Blue annotation is defined like this:

+--------------------------------------
@Qualifier
@Retention(RUNTIME)
@Target( { TYPE, METHOD, FIELD, PARAMETER })
public @interface Blue {
}
+--------------------------------------

 It is an exercise left up to the reader to implement the Red and Yellow annotations.
 
{Basic Injection}

 Lets make our example a little more interesting by injecting a book into Foo.  This is done using the
 JSR-330 standard {{{http://docs.oracle.com/javaee/6/api/javax/inject/Inject.html}Inject}} annotation:
 
+--------------------------------------
@Service
public class FooImpl implements Foo {
  @Inject
  private Book book;
  
  ...
}
+--------------------------------------

 Upon construction the book field will be filled in by HK2.  You can also inject into the constructor of FooImpl, or
 use an initializer method.  In both of those cases the constructor or method must be annotated with
 {{{http://docs.oracle.com/javaee/6/api/javax/inject/Inject.html}@Inject}} in order to tell HK2 which is the proper
 constructor or method to call.
 
 Here is FooImpl implemented with constructor injection:
 
+--------------------------------------
@Service
public class FooImpl implements Foo {
  private final Book book;
  
  @Inject
  public FooImpl(Book book) {
      // constructor injected!
      this.book = book;
  }
}
+--------------------------------------

 Here is FooImpl implemented with initializer method injection:
 
+--------------------------------------
@Service
public class FooImpl implements Foo {
  private Book book;
  
  @Inject
  public void setBook(Book book) {
      // initializer method injected!
      this.book = book;
  }
}
+--------------------------------------

 In all three of the above cases (field injected, constructor injected or initializer method injected) the injection will occur
 prior to the postConstruct method of FooImpl.  In this example we go back to field injection and use the book in our postConstruct
 method:
 
+--------------------------------------
@Service
public class FooImpl implements Foo {
  @Inject
  private Book book;
  
  @PostConstruct
  private void postConstruct() {
      book.doSomething();
  }
}
+--------------------------------------

