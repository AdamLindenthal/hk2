    ------
    Introduction to Modularity with HK2
    ------
    Jerome Dochez
    ------
    ------

    Compatibility note to earlier HK2 developers : Habitat has been replaced with
    a new interface {{{./apidocs/org/glassfish/hk2/Services.html}Services}} and an
    associated DSL for adding and querying services. More information {{{./index.html}here}}.

    Although people can use the layering of services instances offered by the
    {{{./apidocs/org/glassfish/hk2/Services.html}Services}} interfaces coupled
    with strict programmatic visibility expressions between instances of services, most
    development use modules (jar files) as a way to distribute optional software
    parts to form a runtime environment as described {{{./index.html}here}}.

    The runtime environment or the default {{{./apidocs/org/glassfish/hk2/Services.html}Services}} instance
    , will be constructed with the union of all the {{{./apidocs/org/jvnet/hk2/annotations/Contract.html}Contract}}
    implementations and will be used by the HK2 machinery to resolve
    {{{./apidocs/org/jvnet/hk2/annotations/Inject.html}Inject}} dependencies or
    explicit lookup via APIs.

    Therefore, the usual HK2 deployment is a flat namespace where all the services
    are part of a single Services instance (aka Habitat). The namespace will be
    populated with all the services declared in the configured hk2 jar files. The configured jar files
    can be a set of directories (repositories of modules) or can be added programmatically
    or in the case of the embedded mode, the jars present on the classpath.
    For instance, in GlassFish, by default all jars present in a special directory
    like ~glassfish/modules are used to configure the HK2 Runtime.

    So you can see that by adding/removing hk2 jar from that repository of modules,
    the set of services available for resolving dependencies can vary, such property
    can be used to deliver software with different capabilities by changing the set
    of modules delivered. Let's walk through a set of examples to clarify :

        * Simple Substitution : a particular service implementation (capability) has
        a different implementation for each product.

        * Optional dependency : a particular service is available in certain products
        and may be missing in others.

        * Configuration driven dependencies : depending on the configuration of a
        product, a particular implementation of a service should be used.

        * Subclassing : a product implementation has one version, another version has
        a subclass of the first.


Simple substitution

    In this case, a particular version of a product is shipping one version of a
    Service while another version of the same product is shipping a different version.
    Please note that one implementation of that service must exist in any product.
    The first thing to do is to clarify very well the SPI this service implements,
    and define that SPI as an interface annotated with the
    {{{./apidocs/org/jvnet/hk2/annotations/Contract.html}Contract}} annotation.

+-----------------------+
@Contract
public interface MyContract {

    /**
     * Document me well
     */
     void doSomething();
}
+-----------------------+

    Package this interface in a module that will be shipped with both products
    (let's call it services-api.jar).

* Service utilization

    Whether code that wants to use the MyContract service resides in the common
    code to Product A or B, in the code specific to product A or B, it should have access
    to the service implementation using one the following technique

** Declarative Dependency

    By using the {{{./apidocs/org/jvnet/hk2/annotations/Inject.html}Inject}} annotation,
    the code can declare to the system a requirement on a particular service implementation.
    Such declaration will force the HK2 dependency management subsystem to inject the
    resolved MyContract implementation in the instance variable.

+-----------------------+
@Service
public class SomeUserCode {

    @Inject
    MyContract contractImpl;
}
+-----------------------+

    Another way is to use constructor injection :

+-----------------------+
@Service
public class SomeUserCode {

    final MyContract contractImpl;

    SomeUserCode(@Inject MyContract impl) {
        this.contractImpl = impl;
    }
}
+-----------------------+

** Explicit API lookup.

    Provided the user's code has access to the {{{./apidocs/org/glassfish/hk2/Services.html}Services}}
    instance, it can do an explicit service lookup :

+-----------------------+
    MyContract myContractImpl = services.forContract(MyContract.class).get();
    myContractImpl.doSomething();
+-----------------------+

* Implementation Packaging

    In this simple substitution mode, the products will package at least one service or another but never the two of them.
    The simplest way of achieving that result is to define a productA-impl.jar and productB-impl.jar, each containing
    the service implementation and ensure that only one jar is shipped in the final product.

Optional Dependency

    In this mode, a service may be present or absent. It should be used when present but no failure should be generated
    by its absence.

* Optional declarative dependency

+-----------------------+
@Service
public class SomeUserCode {

    @Inject(optional=true)
    MyContract optionalContract = null;


    public void someMethod() {

        if (optionalContract!=null) {
            optionalContract.doSomething();
        }
    }
}

+-----------------------+

* Optional dependency API lookup

    Very similar to the previous case, the explicit lookup should just take into account that a null value can be
    returned.

+-----------------------+
    MyContract myContractImpl = services.forContract(MyContract.class).get();
    if (myContractImpl!=null) {
        myContractImpl.doSomething();
    }
+-----------------------+

* Packaging

    Optional services should be packaged in a separate jar that does not contain any required services implementation
    or contract definitions.

Config Based Dependency

    Sometimes, several competing implementations of a service exist and some configuration should trigger which
    particular implementation should be use. These implementations need to be differentiated and that can be achieved
    by naming each implementation with a different name (String based) or using annotations (Type based).

* String based

    To add a string based name to a contract implementation, use the {{{./apidocs/org/jvnet/hk2/annotations/Service.html}Service}}
    name.

+-----------------------+
@Service(name="foo")
public class MyContractImpl {

    public void doSomething() {

    }
}
+-----------------------+

    Another implementation can then name its implementation different.

+-----------------------+
@Service(name="bar")
public class MyContractImpl {

    public void doSomething() {

    }
}
+-----------------------+

    while to look up will need to use the HK2 APIs to do an explicit lookup.

+-----------------------+
    String serviceName = ... get the service name from config/system property/code ...

    // hopefully service name is either "foo" or "bar"
    MyContract myContractImpl = services.forContract(MyContract.class).named(serviceName).get();
    // you should always check you got what you wanted.
    if (myContractImpl!=null) {
        myContractImpl.doSomething();
    }
+-----------------------+

* Annotation based.

    More type safe but not always as flexible, services implementation can be disambiguated using annotations :

+-----------------------+
@Service
@Basic
public class MyContractImpl {

    public void doSomething() {

    }
}
+-----------------------+

    Another implementation can then name its implementation different.

+-----------------------+
@Service
@Extended
public class MyContractImpl {

    public void doSomething() {

    }
}
+-----------------------+

    while to look up will need to use the HK2 APIs to do an explicit lookup.

+-----------------------+
    Class<? extends Annotation> annotationType = ... get it from config ...

    // hopefully service name is either "foo" or "bar"
    MyContract myContractImpl = services.forContract(MyContract.class).annotatedWith(annotationType).get();
    // you should always check you got what you wanted.
    if (myContractImpl!=null) {
        myContractImpl.doSomething();
    }
+-----------------------+

    of course, nothing prevents you from doing an explicit typed lookup.

+-----------------------+
    MyContract myContractImpl = services.forContract(MyContract.class).annotatedWith(Extended.class).get();

    or

    @Inject
    @Extended
    MyContract myContract;
+-----------------------+

Subclassing

    The casual reader might think that using the last methods (Substitution, Configuration) would work but it has major drawbacks,
     let's look at an example.

+-----------------------+
@Service(name="super")
public class MyContractImpl {

    public void doSomething() {

    }
}
@Service(name="child")
public class MyContract2Impl extends MyContractImpl {

    @Override
    public void doSomething() {
        super.doSomething();
        // do something else
    }
}
+-----------------------+

    The first issue force every client to know if which environment it is operating so it lookups the right implementation
     using a hardcoded name. Obviously you want to have the client code to be un-aware if it is running in particular
     product.

     You could try to do the substitution method but it does not work either since you need the superclass definition in all
     cases (because of the subclassing).

     The simplest solution to this problem is to introduce a level of indirection, adding an abstract class that contains
     all the common code while having 2 subclasses. The first subclass will be a tag class, probably empty that will
     declare the service for the first product. The other subclass will also be annotated with @Service and will be
     containing the second product specific code.

+-----------------------+
// note this class is NOT annotated with @Service
public abstract class AbstractMyContractImpl implements MyContract {
    public void doSomething() {
        ... interesting code ...
    }
}


@Service
public class MyContractImpl extends AbstractMyContractImpl {
}

@Service
public class MyContract2Impl extends AbstractMyContractImpl {

    @Override
    public void doSomething() {
        super.doSomething();
        // do something else
    }
}
+-----------------------+

* Dependency declaration

    The normal declarative or programmatic access to the implementation is similar to case 1, since only one of the two
    @Service annotated class will be shipped in a particular product.

+-----------------------+
@Service
public class SomeUserCode {

    @Inject
    MyContract contractImpl;
}
+-----------------------+

* Packaging

    In order to meet the requirements of visibility, 3 modules are needed.

        * common-impl.jar : will be packaging all common code to product A and B.

        * productA-impl.jar : contains the product A specific @Service classes (MyContractImpl.class in the example above).

        * productB-impl.jar : contains the product B spcecific @Service classes (MyContract2Impl above).