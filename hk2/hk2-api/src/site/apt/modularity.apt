            ------
            Introduction to Modularity with HK2
            ------


Compatibility

    This page is describes modularity with the HK2 2.0 API, which is based on the
    JSR-330 standard annotations.  Also, Habitat has been replaced with a new
    interface called {{{./apidocs/org/glassfish/hk2/api/ServiceLocator.html}ServiceLocator}}.
    More information can be found {{{./index.html}here}}.
    
Use cases

    Although people can use the layering of services instances offered by the
    {{{./apidocs/org/glassfish/hk2/api/ServiceLocator.html}ServiceLocator}} interface
    coupled with strict programmatic visibility, most installations use jar files
    as a way to distribute optional software parts to form a runtime environment.

    When HK2 is started, a default
    {{{./apidocs/org/glassfish/hk2/api/ServiceLocator.html}ServiceLocator}} instance
    will be constructed.  It will contain the union of all the
    {{{./apidocs/org/jvnet/hk2/annotations/Contract.html}Contract}}
    implementations it is told about.  This default
    {{{./apidocs/org/glassfish/hk2/api/ServiceLocator.html}ServiceLocator}} will be used by HK2
    to resolve dependencies indicated with
    {{{http://docs.oracle.com/javaee/6/api/javax/inject/Inject.html}@Inject}}.

    Therefore, the usual HK2 deployment is a flat name space where all the services
    are part of a single {{{./apidocs/org/glassfish/hk2/api/ServiceLocator.html}ServiceLocator}}
    instance.  The name space will be populated with all the services declared in the configured hk2
    jar files.  The configured jar files can be a set of directories (repositories of modules) or can
    be added programmatically.  When running in embedded mode HK2 uses the jars present on the classpath.
    In GlassFish all jars present in a special directory like ~glassfish/modules are used to configure
    the HK2 Runtime.

    So you can see that by adding/removing hk2 jar from the original repository of modules,
    the set of services available for resolving dependencies can vary.  This property
    can be used to deliver software with different capabilities by changing the set
    of modules delivered. Let's walk through a set of examples to clarify :

        * Simple Substitution : a particular service implementation (capability) has
        a different implementation for each product.

        * Optional dependency : a particular service is available in certain products
        and may be missing in others.

        * Configuration driven dependencies : depending on the configuration of a
        product, a particular implementation of a service should be used.

        * Subclassing : a product implementation has one version, another version has
        a subclass of the first.
        
        []

* Simple substitution

    In this case, a particular version of a product is shipping one version of a
    Service while another version of the same product is shipping a different version.
    Please note that one implementation of that service must exist in any product.
    The first thing to do is to clarify very well the SPI this service implements,
    and define that SPI as an interface annotated with the
    {{{./apidocs/org/jvnet/hk2/annotations/Contract.html}Contract}} annotation.

+-----------------------+
@Contract
public interface MyContract {

    /**
     * Document me well
     */
     void doSomething();
}
+-----------------------+

    Package this interface in a module that will be shipped with both products
    (let's call it services-api.jar).

** Service utilization

    Whether code that wants to use the MyContract service resides in the common
    code to Product A or B, in the code specific to product A or B, it should have access
    to the service implementation using one the following technique

*** Declarative Dependency

    By using the {{{http://docs.oracle.com/javaee/6/api/javax/inject/Inject.html}Inject}} annotation,
    the code can declare to the system a requirement on a particular service implementation.
    Such declaration will force the HK2 dependency management subsystem to inject the
    resolved MyContract implementation in the instance variable.

+-----------------------+
@Service
public class SomeUserCode {

    @Inject
    MyContract contractImpl;
}
+-----------------------+

    Another way is to use constructor injection :

+-----------------------+
@Service
public class SomeUserCode {

    final MyContract contractImpl;

    @Inject
    SomeUserCode(MyContract impl) {
        this.contractImpl = impl;
    }
}
+-----------------------+

*** Explicit API lookup.

    Provided the user's code has access to the
    {{{./apidocs/org/glassfish/hk2/api/ServiceLocator.html}ServiceLocator}}
    instance, it can do an explicit service lookup :

+-----------------------+
    MyContract myContractImpl = serviceLocator.getService(MyContract.class);
    myContractImpl.doSomething();
+-----------------------+

** Implementation Packaging

    In this simple substitution mode, the products will package at least one service or another but
    never the two of them.  The simplest way of achieving that result is to define a productA-impl.jar
    and productB-impl.jar, each containing the service implementation and ensure that only one jar is
    shipped in the final product.

* Optional Dependency

    In this mode, a service may be present or absent. It should be used when present but no failure
    should be generated by its absence.

** Optional declarative dependency

+-----------------------+
@Service
public class SomeUserCode {

    @Inject @Optional
    MyContract optionalContract = null;


    public void someMethod() {

        if (optionalContract!=null) {
            optionalContract.doSomething();
        }
    }
}

+-----------------------+

** Optional dependency API lookup

    Very similar to the previous case, the explicit lookup should just take into account that a null
    value can be returned.

+-----------------------+
    MyContract myContractImpl = serviceLocator.getService(MyContract.class);
    if (myContractImpl!=null) {
        myContractImpl.doSomething();
    }
+-----------------------+

** Packaging

    Optional services should be packaged in a separate jar that does not contain any required services
    implementation or contract definitions.

* Config Based Dependency

    Sometimes, several competing implementations of a service exist and some configuration should trigger
    which particular implementation should be use. These implementations need to be differentiated and
    that can be achieved by naming each implementation with a different name (String based) or using
    annotations (Type based).

** String based

    To add a string based name to a contract implementation, use the
    {{{http://docs.oracle.com/javaee/6/api/javax/inject/Named.html}Named}}
    qualifier annotation.

+-----------------------+
@Service @Named("foo")
public class MyContractImpl {

    public void doSomething() {

    }
}
+-----------------------+

    Another implementation can then name its implementation different.

+-----------------------+
@Service @Named("bar")
public class MyContractImpl {

    public void doSomething() {

    }
}
+-----------------------+

    while to look up will need to use the HK2 APIs to do an explicit lookup.

+-----------------------+
    String serviceName = ... get the service name from config/system property/code ...

    // hopefully service name is either "foo" or "bar"
    MyContract myContractImpl = serviceLocator.getService(MyContract.class, serviceName);
    // you should always check you got what you wanted.
    if (myContractImpl!=null) {
        myContractImpl.doSomething();
    }
+-----------------------+

** Qualifier based

    More type safe but not always as flexible, services implementation can be disambiguated using
    qualifiers, which are special annotations that are themselves annotated with
    {{{http://docs.oracle.com/javaee/6/api/javax/inject/Qualifier.html}@Qualifier}}.

+-----------------------+
@Service
@Basic
public class MyContractImpl {

    public void doSomething() {

    }
}
+-----------------------+

    Another implementation can then name its implementation different.

+-----------------------+
@Service
@Extended
public class MyContractImpl {

    public void doSomething() {

    }
}
+-----------------------+

    while to look up will need to use the HK2 APIs to do an explicit lookup, and
    instantiate an object by extending an
    {{{./apidocs/org/glassfish/hk2/api/AnnotationLiteral.html}AnnotationLiteral}}.

+-----------------------+
    Annotation annotation = ... get it from config ...

    // hopefully service name is either "foo" or "bar"
    MyContract myContractImpl = serviceLocator.getService(MyContract.class, annotation);
    // you should always check you got what you wanted.
    if (myContractImpl!=null) {
        myContractImpl.doSomething();
    }
+-----------------------+

    of course, nothing prevents you from doing an injection based on a qualifier.

+-----------------------+
    @Inject
    @Extended
    MyContract myContract;
+-----------------------+

* Subclassing

    The casual reader might think that using the last methods (Substitution, Configuration) would work but
    it has major drawbacks.  Let's look at an example.

+-----------------------+
@Service @Named("super")
public class MyContractImpl {

    public void doSomething() {

    }
}

@Service @Named("child")
public class MyContract2Impl extends MyContractImpl {

    @Override
    public void doSomething() {
        super.doSomething();
        // do something else
    }
}
+-----------------------+

    The first issue is that it forces every client to know which environment it is operating in so it
    looks up the correct implementation using a hard-coded name. Instead we want the client code
    to be un-aware of the environment in which it is running.

     You could try to do the substitution method but it does not work since you need the superclass
     definition in all cases (because of the subclassing).

     The simplest solution to this problem is to introduce a level of indirection, adding an abstract
     class that contains all the common code while having 2 subclasses. The first subclass will be a tag
     class, probably empty that will declare the service for the first product. The other subclass will
     also be annotated with @Service and will contain the second product specific code.

+-----------------------+
// note this class is NOT annotated with @Service
public abstract class AbstractMyContractImpl implements MyContract {
    public void doSomething() {
        ... interesting code ...
    }
}


@Service
public class MyContractImpl extends AbstractMyContractImpl {
}

@Service
public class MyContract2Impl extends AbstractMyContractImpl {

    @Override
    public void doSomething() {
        super.doSomething();
        // do something else
    }
}
+-----------------------+

** Dependency declaration

    The normal declarative or programmatic access to the implementation is similar to case 1, since only
    one of the two @Service annotated class will be shipped in a particular product.

+-----------------------+
@Service
public class SomeUserCode {

    @Inject
    MyContract contractImpl;
}
+-----------------------+

* Packaging

    In order to meet the requirements of visibility, 3 modules are needed.

        * common-impl.jar : will be packaging all common code to product A and B.

        * productA-impl.jar : contains the product A specific @Service classes (MyContractImpl.class in the example above).

        * productB-impl.jar : contains the product B spcecific @Service classes (MyContract2Impl above).